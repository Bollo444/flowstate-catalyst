"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  EMPTY_BUFFER\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n  return buf;\n}\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?32c4\");\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil.mask(source, mask, output, offset, length);\n    };\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBYSxDQUFDLEdBQUdDLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUUvQyxNQUFNQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxNQUFNQSxDQUFDQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtFQUNqQyxJQUFJRCxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT1QsWUFBWTtFQUMxQyxJQUFJTyxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT0YsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUVyQyxNQUFNRyxNQUFNLEdBQUdQLE1BQU0sQ0FBQ1EsV0FBVyxDQUFDSCxXQUFXLENBQUM7RUFDOUMsSUFBSUksTUFBTSxHQUFHLENBQUM7RUFFZCxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR04sSUFBSSxDQUFDRSxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFO0lBQ3BDLE1BQU1DLEdBQUcsR0FBR1AsSUFBSSxDQUFDTSxDQUFDLENBQUM7SUFDbkJILE1BQU0sQ0FBQ0ssR0FBRyxDQUFDRCxHQUFHLEVBQUVGLE1BQU0sQ0FBQztJQUN2QkEsTUFBTSxJQUFJRSxHQUFHLENBQUNMLE1BQU07RUFDdEI7RUFFQSxJQUFJRyxNQUFNLEdBQUdKLFdBQVcsRUFBRTtJQUN4QixPQUFPLElBQUlOLFVBQVUsQ0FBQ1EsTUFBTSxDQUFDTSxNQUFNLEVBQUVOLE1BQU0sQ0FBQ08sVUFBVSxFQUFFTCxNQUFNLENBQUM7RUFDakU7RUFFQSxPQUFPRixNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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RUFBRVQsTUFBTSxFQUFFSCxNQUFNLENBQUM7SUFDNUQsQ0FBQztJQUVEd0IscUJBQXFCLEdBQUcsVUFBVWpCLE1BQU0sRUFBRUksSUFBSSxFQUFFO01BQzlDLElBQUlKLE1BQU0sQ0FBQ1AsTUFBTSxHQUFHLEVBQUUsRUFBRWEsT0FBTyxDQUFDTixNQUFNLEVBQUVJLElBQUksQ0FBQyxDQUFDLEtBQ3pDbUIsVUFBVSxDQUFDSixNQUFNLENBQUNuQixNQUFNLEVBQUVJLElBQUksQ0FBQztJQUN0QyxDQUFDO0VBQ0gsQ0FBQyxDQUFDLE9BQU9vQixDQUFDLEVBQUU7SUFDVjtFQUFBO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzPzZlMGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25jYXQsXG4gIG1hc2s6IF9tYXNrLFxuICB0b0FycmF5QnVmZmVyLFxuICB0b0J1ZmZlcixcbiAgdW5tYXNrOiBfdW5tYXNrXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbmlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnVubWFzayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFTVBUWV9CVUZGRVIiLCJyZXF1aXJlIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJsZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsImkiLCJidWYiLCJzZXQiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiX21hc2siLCJzb3VyY2UiLCJtYXNrIiwib3V0cHV0IiwiX3VubWFzayIsInRvQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic2xpY2UiLCJ0b0J1ZmZlciIsImRhdGEiLCJyZWFkT25seSIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmcm9tIiwibW9kdWxlIiwiZXhwb3J0cyIsInVubWFzayIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19CVUZGRVJfVVRJTCIsImJ1ZmZlclV0aWwiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\nif (hasBlob) BINARY_TYPES.push('blob');\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNQSxZQUFZLEdBQUcsQ0FBQyxZQUFZLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQztBQUMvRCxNQUFNQyxPQUFPLEdBQUcsT0FBT0MsSUFBSSxLQUFLLFdBQVc7QUFFM0MsSUFBSUQsT0FBTyxFQUFFRCxZQUFZLENBQUNHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFFdENDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZMLFlBQVk7RUFDWk0sWUFBWSxFQUFFQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0JDLElBQUksRUFBRSxzQ0FBc0M7RUFDNUNSLE9BQU87RUFDUFMsb0JBQW9CLEVBQUVDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQztFQUN0REMsU0FBUyxFQUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDO0VBQzlCRSxXQUFXLEVBQUVGLE1BQU0sQ0FBQyxhQUFhLENBQUM7RUFDbENHLFVBQVUsRUFBRUgsTUFBTSxDQUFDLFdBQVcsQ0FBQztFQUMvQkksSUFBSSxFQUFFQSxDQUFBLEtBQU0sQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz9jMmEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuY29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcbiAgaGFzQmxvYixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIE5PT1A6ICgpID0+IHt9XG59O1xuIl0sIm5hbWVzIjpbIkJJTkFSWV9UWVBFUyIsImhhc0Jsb2IiLCJCbG9iIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJFTVBUWV9CVUZGRVIiLCJCdWZmZXIiLCJhbGxvYyIsIkdVSUQiLCJrRm9yT25FdmVudEF0dHJpYnV0ZSIsIlN5bWJvbCIsImtMaXN0ZW5lciIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsIk5PT1AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBLG9CQUFvQjtFQUFFQztBQUFVLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyw2REFBYSxDQUFDO0FBRWxFLE1BQU1DLEtBQUssR0FBR0MsTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNQyxLQUFLLEdBQUdELE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDN0IsTUFBTUUsTUFBTSxHQUFHRixNQUFNLENBQUMsUUFBUSxDQUFDO0FBQy9CLE1BQU1HLFFBQVEsR0FBR0gsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUNuQyxNQUFNSSxPQUFPLEdBQUdKLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDakMsTUFBTUssT0FBTyxHQUFHTCxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ2pDLE1BQU1NLEtBQUssR0FBR04sTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNTyxTQUFTLEdBQUdQLE1BQU0sQ0FBQyxXQUFXLENBQUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE1BQU1RLEtBQUssQ0FBQztFQUNWO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFDQyxJQUFJLEVBQUU7SUFDaEIsSUFBSSxDQUFDTCxPQUFPLENBQUMsR0FBRyxJQUFJO0lBQ3BCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEdBQUdJLElBQUk7RUFDcEI7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsSUFBSUMsTUFBTUEsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJLENBQUNOLE9BQU8sQ0FBQztFQUN0Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxJQUFJSyxJQUFJQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDO0VBQ3BCO0FBQ0Y7QUFFQU0sTUFBTSxDQUFDQyxjQUFjLENBQUNMLEtBQUssQ0FBQ00sU0FBUyxFQUFFLFFBQVEsRUFBRTtFQUFF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QVEsQ0FBQztRQUNuQztNQUNGO0lBQ0Y7RUFDRjtBQUNGLENBQUM7QUFFRGlCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZoQyxVQUFVO0VBQ1ZNLFVBQVU7RUFDVmQsS0FBSztFQUNMbUIsV0FBVztFQUNYRjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNZLFlBQVlBLENBQUNQLFFBQVEsRUFBRW1CLE9BQU8sRUFBRWQsS0FBSyxFQUFFO0VBQzlDLElBQUksT0FBT0wsUUFBUSxLQUFLLFFBQVEsSUFBSUEsUUFBUSxDQUFDb0IsV0FBVyxFQUFFO0lBQ3hEcEIsUUFBUSxDQUFDb0IsV0FBVyxDQUFDQyxJQUFJLENBQUNyQixRQUFRLEVBQUVLLEtBQUssQ0FBQztFQUM1QyxDQUFDLE1BQU07SUFDTEwsUUFBUSxDQUFDcUIsSUFBSSxDQUFDRixPQUFPLEVBQUVkLEtBQUssQ0FBQztFQUMvQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/MzM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsInJlcXVpcmUiLCJrQ29kZSIsIlN5bWJvbCIsImtEYXRhIiwia0Vycm9yIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ0YXJnZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50Iiwib3B0aW9ucyIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJNZXNzYWdlRXZlbnQiLCJkYXRhIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwid3JhcHBlciIsIm9uTWVzc2FnZSIsImlzQmluYXJ5IiwiZXZlbnQiLCJ0b1N0cmluZyIsImNhbGxMaXN0ZW5lciIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25FcnJvciIsIm9uT3BlbiIsIm9uY2UiLCJvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0aGlzQXJnIiwiaGFuZGxlRXZlbnQiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions).map(extension => {\n    let configurations = extensions[extension];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\nmodule.exports = {\n  format,\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBO0FBQVcsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLCtEQUFjLENBQUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsSUFBSUEsQ0FBQ0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtFQUM5QixJQUFJRixJQUFJLENBQUNDLElBQUksQ0FBQyxLQUFLRSxTQUFTLEVBQUVILElBQUksQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsS0FDN0NGLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0UsS0FBS0EsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3JCLE1BQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2xDLElBQUlDLE1BQU0sR0FBR0YsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2hDLElBQUlFLFlBQVksR0FBRyxLQUFLO0VBQ3hCLElBQUlDLFVBQVUsR0FBRyxLQUFLO0VBQ3RCLElBQUlDLFFBQVEsR0FBRyxLQUFLO0VBQ3BCLElBQUlDLGFBQWE7RUFDakIsSUFBSUMsU0FBUztFQUNiLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0VBQ2IsSUFBSUMsR0FBRyxHQUFHLENBQUMsQ0FBQztFQUNaLElBQUlDLENBQUMsR0FBRyxDQUFDO0VBRVQsT0FBT0EsQ0FBQyxHQUFHYixNQUFNLENBQUNjLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7SUFDN0JGLElBQUksR0FBR1gsTUFBTSxDQUFDZSxV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RUFBRXRCO0FBQU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb3dzdGF0ZS1jYXRhbHlzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzP2EzMmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicHVzaCIsImRlc3QiLCJuYW1lIiwiZWxlbSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaGVhZGVyIiwib2ZmZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwicGFyYW1zIiwibXVzdFVuZXNjYXBlIiwiaXNFc2NhcGluZyIsImluUXVvdGVzIiwiZXh0ZW5zaW9uTmFtZSIsInBhcmFtTmFtZSIsInN0YXJ0IiwiY29kZSIsImVuZCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJzbGljZSIsInZhbHVlIiwicmVwbGFjZSIsInRva2VuIiwiZm9ybWF0IiwiZXh0ZW5zaW9ucyIsImtleXMiLCJtYXAiLCJleHRlbnNpb24iLCJjb25maWd1cmF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImsiLCJ2YWx1ZXMiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\nmodule.exports = Limiter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTUEsS0FBSyxHQUFHQyxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQzdCLE1BQU1DLElBQUksR0FBR0QsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSxPQUFPLENBQUM7RUFDWjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBQ0MsV0FBVyxFQUFFO0lBQ3ZCLElBQUksQ0FBQ0wsS0FBSyxDQUFDLEdBQUcsTUFBTTtNQUNsQixJQUFJLENBQUNNLE9BQU8sRUFBRTtNQUNkLElBQUksQ0FBQ0osSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNkLENBQUM7SUFDRCxJQUFJLENBQUNHLFdBQVcsR0FBR0EsV0FBVyxJQUFJRSxRQUFRO0lBQzFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7SUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBRyxDQUFDO0VBQ2xCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFRyxHQUFHQSxDQUFDQyxHQUFHLEVBQUU7SUFDUCxJQUFJLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDRCxHQUFHLENBQUM7SUFDbkIsSUFBSSxDQUFDUixJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ2Q7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLENBQUNBLElBQUksSUFBSTtJQUNQLElBQUksSUFBSSxDQUFDSSxPQUFPLEtBQUssSUFBSSxDQUFDRCxXQUFXLEVBQUU7SUFFdkMsSUFBSSxJQUFJLENBQUNHLElBQUksQ0FBQ0ksTUFBTSxFQUFFO01BQ3BCLE1BQU1GLEdBQUcsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0ssS0FBSyxDQUFDLENBQUM7TUFFN0IsSUFBSSxDQUFDUCxPQUFPLEVBQUU7TUFDZEksR0FBRyxDQUFDLElBQUksQ0FBQ1YsS0FBSyxDQUFDLENBQUM7SUFDbEI7RUFDRjtBQUNGO0FBRUFjLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWixPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzPzgwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIl0sIm5hbWVzIjpbImtEb25lIiwiU3ltYm9sIiwia1J1biIsIkxpbWl0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbmN1cnJlbmN5IiwicGVuZGluZyIsIkluZmluaXR5Iiwiam9icyIsImFkZCIsImpvYiIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./node_modules/ws/lib/limiter.js\");\nconst {\n  kStatusCode\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(new Error('The deflate stream was closed while data was being processed'));\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw(_objectSpread(_objectSpread({}, this._options.zlibInflateOptions), {}, {\n        windowBits\n      }));\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw(_objectSpread(_objectSpread({}, this._options.zlibDeflateOptions), {}, {\n        windowBits\n      }));\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on('data', deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data);\n    });\n  }\n}\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxTQUFBQSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFlLGVBQUEsQ0FBQWhCLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYyx5QkFBQSxHQUFBZCxNQUFBLENBQUFlLGdCQUFBLENBQUFsQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWMseUJBQUEsQ0FBQWYsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZ0IsY0FBQSxDQUFBbkIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQU4sQ0FBQSxFQUFBRCxDQUFBLGlCQUFBRCxDQUFBO0FBQUEsU0FBQWdCLGdCQUFBSSxHQUFBLEVBQUFDLEdBQUEsRUFBQUMsS0FBQSxJQUFBRCxHQUFBLEdBQUFFLGNBQUEsQ0FBQUYsR0FBQSxPQUFBQSxHQUFBLElBQUFELEdBQUEsSUFBQWpCLE1BQUEsQ0FBQWdCLGNBQUEsQ0FBQUMsR0FBQSxFQUFBQyxHQUFBLElBQUFDLEtBQUEsRUFBQUEsS0FBQSxFQUFBYixVQUFBLFFBQUFlLFlBQUEsUUFBQUMsUUFBQSxvQkFBQUwsR0FBQSxDQUFBQyxHQUFBLElBQUFDLEtBQUEsV0FBQUYsR0FBQTtBQUFBLFNBQUFHLGVBQUFHLEdBQUEsUUFBQUwsR0FBQSxHQUFBTSxZQUFBLENBQUFELEdBQUEsMkJBQUFMLEdBQUEsZ0JBQUFBLEdBQUEsR0FBQU8sTUFBQSxDQUFBUCxHQUFBO0FBQUEsU0FBQU0sYUFBQUUsS0FBQSxFQUFBQyxJQUFBLGVBQUFELEtBQUEsaUJBQUFBLEtBQUEsa0JBQUFBLEtBQUEsTUFBQUUsSUFBQSxHQUFBRixLQUFBLENBQUFHLE1BQUEsQ0FBQUMsV0FBQSxPQUFBRixJQUFBLEtBQUFHLFNBQUEsUUFBQUMsR0FBQSxHQUFBSixJQUFBLENBQUFLLElBQUEsQ0FBQVAsS0FBQSxFQUFBQyxJQUFBLDJCQUFBSyxHQUFBLHNCQUFBQSxHQUFBLFlBQUFFLFNBQUEsNERBQUFQLElBQUEsZ0JBQUFGLE1BQUEsR0FBQVUsTUFBQSxFQUFBVCxLQUFBO0FBRWIsTUFBTVUsSUFBSSxHQUFHQyxtQkFBTyxDQUFDLGtCQUFNLENBQUM7QUFFNUIsTUFBTUMsVUFBVSxHQUFHRCxtQkFBTyxDQUFDLGlFQUFlLENBQUM7QUFDM0MsTUFBTUUsT0FBTyxHQUFHRixtQkFBTyxDQUFDLHlEQUFXLENBQUM7QUFDcEMsTUFBTTtFQUFFRztBQUFZLENBQUMsR0FBR0gsbUJBQU8sQ0FBQyw2REFBYSxDQUFDO0FBRTlDLE1BQU1JLFVBQVUsR0FBR0MsTUFBTSxDQUFDYixNQUFNLENBQUNjLE9BQU8sQ0FBQztBQUN6QyxNQUFNQyxPQUFPLEdBQUdGLE1BQU0sQ0FBQ0csSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckQsTUFBTUMsa0JBQWtCLEdBQUdqQixNQUFNLENBQUMsb0JBQW9CLENBQUM7QUFDdkQsTUFBTWtCLFlBQVksR0FBR2xCLE1BQU0sQ0FBQyxjQUFjLENBQUM7QUFDM0MsTUFBTW1CLFNBQVMsR0FBR25CLE1BQU0sQ0FBQyxVQUFVLENBQUM7QUFDcEMsTUFBTW9CLFFBQVEsR0FBR3BCLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDbEMsTUFBTXFCLE1BQU0sR0FBR3JCLE1BQU0sQ0FBQyxPQUFPLENBQUM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSXNCLFdBQVc7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsaUJBQWlCLENBQUM7RUFDdEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLFdBQVdBLENBQUNDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQUU7SUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdELFVBQVUsR0FBRyxDQUFDO0lBQ2pDLElBQUksQ0FBQ0UsUUFBUSxHQUFHSixPQUFPLElBQUksQ0FBQyxDQUFDO0lBQzdCLElBQUksQ0FBQ0ssVUFBVSxHQUNiLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxTQUFTLEtBQUs3QixTQUFTLEdBQUcsSUFBSSxDQUFDMkIsUUFBUSxDQUFDRSxTQUFTLEdBQUcsSUFBSTtJQUN4RSxJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDLENBQUNOLFFBQVE7SUFDM0IsSUFBSSxDQUFDTyxRQUFRLEdBQUcsSUFBSTtJQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJO0lBRXBCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUk7SUFFbEIsSUFBSSxDQUFDYixXQUFXLEVBQUU7TUFDaEIsTUFBTWMsV0FBVyxHQUNmLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxnQkFBZ0IsS0FBS25DLFNBQVMsR0FDeEMsSUFBSSxDQUFDMkIsUUFBUSxDQUFDUSxnQkFBZ0IsR0FDOUIsRUFBRTtNQUNSZixXQUFXLEdBQUcsSUFBSVosT0FBTyxDQUFDMEIsV0FBVyxDQUFDO0lBQ3hDO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsV0FBV0UsYUFBYUEsQ0FBQSxFQUFHO0lBQ3pCLE9BQU8sb0JBQW9CO0VBQzdCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxLQUFLQSxDQUFBLEVBQUc7SUFDTixNQUFNSixNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBRWpCLElBQUksSUFBSSxDQUFDTixRQUFRLENBQUNXLHVCQUF1QixFQUFFO01BQ3pDTCxNQUFNLENBQUNNLDBCQUEwQixHQUFHLElBQUk7SUFDMUM7SUFDQSxJQUFJLElBQUksQ0FBQ1osUUFBUSxDQUFDYSx1QkFBdUIsRUFBRTtNQUN6Q1AsTUFBTSxDQUFDUSwwQkFBMEIsR0FBRyxJQUFJO0lBQzFDO0lBQ0EsSUFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2UsbUJBQW1CLEVBQUU7TUFDckNULE1BQU0sQ0FBQ1Usc0JBQXNCLEdBQUcsSUFBSSxDQUFDaEIsUUFBUSxDQUFDZSxtQkFBbUI7SUFDbkU7SUFDQSxJQUFJLElBQUksQ0FBQ2YsUUFBUSxDQUFDaUIsbUJBQW1CLEVBQUU7TUFDckNYLE1BQU0sQ0FBQ1ksc0JBQXNCLEdBQUcsSUFBSSxDQUFDbEIsUUFBUSxDQUFDaUIsbUJBQW1CO0lBQ25FLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ2lCLG1CQUFtQixJQUFJLElBQUksRUFBRTtNQUNwRFgsTUFBTSxDQUFDWSxzQkFBc0IsR0FBRyxJQUFJO0lBQ3RDO0lBRUEsT0FBT1osTUFBTTtFQUNmOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VhLE1BQU1BLENBQUNDLGNBQWMsRUFBRTtJQUNyQkEsY0FBYyxHQUFHLElBQUksQ0FBQ0MsZUFBZSxDQUFDRCxjQUFjLENBQUM7SUFFckQsSUFBSSxDQUFDZCxNQUFNLEdBQUcsSUFBSSxDQUFDSCxTQUFTLEdBQ3hCLElBQUksQ0FBQ21CLGNBQWMsQ0FBQ0YsY0FBYyxDQUFDLEdBQ25DLElBQUksQ0FBQ0csY0FBYyxDQUFDSCxjQUFjLENBQUM7SUFFdkMsT0FBTyxJQUFJLENBQUNkLE1BQU07RUFDcEI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFa0IsT0FBT0EsQ0FBQSxFQUFHO0lBQ1IsSUFBSSxJQUFJLENBQUNuQixRQUFRLEVBQUU7TUFDakIsSUFBSSxDQUFDQSxRQUFRLENBQUNvQixLQUFLLENBQUMsQ0FBQztNQUNyQixJQUFJLENBQUNwQixRQUFRLEdBQUcsSUFBSTtJQUN0QjtJQUVBLElBQUksSUFBSSxDQUFDRCxRQUFRLEVBQUU7TUFDakIsTUFBTXNCLFFBQVEsR0FBRyxJQUFJLENBQUN0QixRQUFRLENBQUNkLFNBQVMsQ0FBQztNQUV6QyxJQUFJLENBQUNjLFFBQVEsQ0FBQ3FCLEtBQUssQ0FBQyxDQUFDO01BQ3JCLElBQUksQ0FBQ3JCLFFBQVEsR0FBRyxJQUFJO01BRXBCLElBQUlzQixRQUFRLEVBQUU7UUFDWkEsUUFBUSxDQUNOLElBQUlDLEtBQUssQ0FDUCw4REFDRixDQUNGLENBQUM7TUFDSDtJQUNGO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUwsY0FBY0EsQ0FBQ00sTUFBTSxFQUFFO0lBQ3JCLE1BQU1DLElBQUksR0FBRyxJQUFJLENBQUM3QixRQUFRO0lBQzFCLE1BQU04QixRQUFRLEdBQUdGLE1BQU0sQ0FBQ0csSUFBSSxDQUFFekIsTUFBTSxJQUFLO01BQ3ZDLElBQ0d1QixJQUFJLENBQUNsQix1QkFBdUIsS0FBSyxLQUFLLElBQ3JDTCxNQUFNLENBQUNNLDBCQUEwQixJQUNsQ04sTUFBTSxDQUFDVSxzQkFBc0IsS0FDM0JhLElBQUksQ0FBQ2QsbUJBQW1CLEtBQUssS0FBSyxJQUNoQyxPQUFPYyxJQUFJLENBQUNkLG1CQUFtQixLQUFLLFFBQVEsSUFDM0NjLElBQUksQ0FBQ2QsbUJBQW1CLEdBQUdULE1BQU0sQ0FBQ1Usc0JBQXVCLENBQUUsSUFDaEUsT0FBT2EsSUFBSSxDQUFDWixtQkFBbUIsS0FBSyxRQUFRLElBQzNDLENBQUNYLE1BQU0sQ0FBQ1ksc0JBQXVCLEVBQ2pDO1FBQ0EsT0FBTyxLQUFLO01BQ2Q7TUFFQSxPQUFPLElBQUk7SUFDYixDQUFDLENBQUM7SUFFRixJQUFJLENBQUNZLFFBQVEsRUFBRTtNQUNiLE1BQU0sSUFBSUgsS0FBSyxDQUFDLDhDQUE4QyxDQUFDO0lBQ2pFO0lBRUEsSUFBSUUsSUFBSSxDQUFDbEIsdUJBQXVCLEVBQUU7TUFDaENtQixRQUFRLENBQUNsQiwwQkFBMEIsR0FBRyxJQUFJO0lBQzVDO0lBQ0EsSUFBSWlCLElBQUksQ0FBQ2hCLHVCQUF1QixFQUFFO01BQ2hDaUIsUUFBUSxDQUFDaEIsMEJBQTBCLEdBQUcsSUFBSTtJQUM1QztJQUNBLElBQUksT0FBT2UsSUFBSSxDQUFDZCxtQkFBbUIsS0FBSyxRQUFRLEVBQUU7TUFDaERlLFFBQVEsQ0FBQ2Qsc0JBQXNCLEdBQUdhLElBQUksQ0FBQ2QsbUJBQW1CO0lBQzVEO0lBQ0EsSUFBSSxPQUFPYyxJQUFJLENBQUNaLG1CQUFtQixLQUFLLFFBQVEsRUFBRTtNQUNoRGEsUUFBUSxDQUFDWixzQkFBc0IsR0FBR1csSUFBSSxDQUFDWixtQkFBbUI7SUFDNUQsQ0FBQyxNQUFNLElBQ0xhLFFBQVEsQ0FBQ1osc0JBQXNCLEtBQUssSUFBSSxJQUN4Q1csSUFBSSxDQUFDWixtQkFBbUIsS0FBSyxLQUFLLEVBQ2xDO01BQ0EsT0FBT2EsUUFBUSxDQUFDWixzQkFBc0I7SUFDeEM7SUFFQSxPQUFPWSxRQUFRO0VBQ2pCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VQLGNBQWNBLENBQUNTLFFBQVEsRUFBRTtJQUN2QixNQUFNMUIsTUFBTSxHQUFHMEIsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUUxQixJQUNFLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQ2EsdUJBQXVCLEtBQUssS0FBSyxJQUMvQ1AsTUFBTSxDQUFDUSwwQkFBMEIsRUFDakM7TUFDQSxNQUFNLElBQUlhLEtBQUssQ0FBQyxtREFBbUQsQ0FBQztJQUN0RTtJQUVBLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ1ksc0JBQXNCLEVBQUU7TUFDbEMsSUFBSSxPQUFPLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ2lCLG1CQUFtQixLQUFLLFFBQVEsRUFBRTtRQUN6RFgsTUFBTSxDQUFDWSxzQkFBc0IsR0FBRyxJQUFJLENBQUNsQixRQUFRLENBQUNpQixtQkFBbUI7TUFDbkU7SUFDRixDQUFDLE1BQU0sSUFDTCxJQUFJLENBQUNqQixRQUFRLENBQUNpQixtQkFBbUIsS0FBSyxLQUFLLElBQzFDLE9BQU8sSUFBSSxDQUFDakIsUUFBUSxDQUFDaUIsbUJBQW1CLEtBQUssUUFBUSxJQUNwRFgsTUFBTSxDQUFDWSxzQkFBc0IsR0FBRyxJQUFJLENBQUNsQixRQUFRLENBQUNpQixtQkFBb0IsRUFDcEU7TUFDQSxNQUFNLElBQUlVLEtBQUssQ0FDYiwwREFDRixDQUFDO0lBQ0g7SUFFQSxPQUFPckIsTUFBTTtFQUNmOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VlLGVBQWVBLENBQUNELGNBQWMsRUFBRTtJQUM5QkEsY0FBYyxDQUFDbEUsT0FBTyxDQUFFb0QsTUFBTSxJQUFLO01BQ2pDaEUsTUFBTSxDQUFDQyxJQUFJLENBQUMrRCxNQUFNLENBQUMsQ0FBQ3BELE9BQU8sQ0FBRU0sR0FBRyxJQUFLO1FBQ25DLElBQUlDLEtBQUssR0FBRzZDLE1BQU0sQ0FBQzlDLEdBQUcsQ0FBQztRQUV2QixJQUFJQyxLQUFLLENBQUNSLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDcEIsTUFBTSxJQUFJMEUsS0FBSyxDQUFFLGNBQWFuRSxHQUFJLGlDQUFnQyxDQUFDO1FBQ3JFO1FBRUFDLEtBQUssR0FBR0EsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVoQixJQUFJRCxHQUFHLEtBQUssd0JBQXdCLEVBQUU7VUFDcEMsSUFBSUMsS0FBSyxLQUFLLElBQUksRUFBRTtZQUNsQixNQUFNd0UsR0FBRyxHQUFHLENBQUN4RSxLQUFLO1lBQ2xCLElBQUksQ0FBQ2dCLE1BQU0sQ0FBQ3lELFNBQVMsQ0FBQ0QsR0FBRyxDQUFDLElBQUlBLEdBQUcsR0FBRyxDQUFDLElBQUlBLEdBQUcsR0FBRyxFQUFFLEVBQUU7Y0FDakQsTUFBTSxJQUFJekQsU0FBUyxDQUNoQixnQ0FBK0JoQixHQUFJLE1BQUtDLEtBQU0sRUFDakQsQ0FBQztZQUNIO1lBQ0FBLEtBQUssR0FBR3dFLEdBQUc7VUFDYixDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUMxQixNQUFNLElBQUkzQixTQUFTLENBQ2hCLGdDQUErQmhCLEdBQUksTUFBS0MsS0FBTSxFQUNqRCxDQUFDO1VBQ0g7UUFDRixDQUFDLE1BQU0sSUFBSUQsR0FBRyxLQUFLLHdCQUF3QixFQUFFO1VBQzNDLE1BQU15RSxHQUFHLEdBQUcsQ0FBQ3hFLEtBQUs7VUFDbEIsSUFBSSxDQUFDZ0IsTUFBTSxDQUFDeUQsU0FBUyxDQUFDRCxHQUFHLENBQUMsSUFBSUEsR0FBRyxHQUFHLENBQUMsSUFBSUEsR0FBRyxHQUFHLEVBQUUsRUFBRTtZQUNqRCxNQUFNLElBQUl6RCxTQUFTLENBQ2hCLGdDQUErQmhCLEdBQUksTUFBS0MsS0FBTSxFQUNqRCxDQUFDO1VBQ0g7VUFDQUEsS0FBSyxHQUFHd0UsR0FBRztRQUNiLENBQUMsTUFBTSxJQUNMekUsR0FBRyxLQUFLLDRCQUE0QixJQUNwQ0EsR0FBRyxLQUFLLDRCQUE0QixFQUNwQztVQUNBLElBQUlDLEtBQUssS0FBSyxJQUFJLEVBQUU7WUFDbEIsTUFBTSxJQUFJZSxTQUFTLENBQ2hCLGdDQUErQmhCLEdBQUksTUFBS0MsS0FBTSxFQUNqRCxDQUFDO1VBQ0g7UUFDRixDQUFDLE1BQU07VUFDTCxNQUFNLElBQUlrRSxLQUFLLENBQUUsc0JBQXFCbkUsR0FBSSxHQUFFLENBQUM7UUFDL0M7UUFFQThDLE1BQU0sQ0FBQzlDLEdBQUcsQ0FBQyxHQUFHQyxLQUFLO01BQ3JCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztJQUVGLE9BQU8yRCxjQUFjO0VBQ3ZCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWUsVUFBVUEsQ0FBQ0MsSUFBSSxFQUFFQyxHQUFHLEVBQUVYLFFBQVEsRUFBRTtJQUM5QmpDLFdBQVcsQ0FBQzZDLEdBQUcsQ0FBRUMsSUFBSSxJQUFLO01BQ3hCLElBQUksQ0FBQ0MsV0FBVyxDQUFDSixJQUFJLEVBQUVDLEdBQUcsRUFBRSxDQUFDSSxHQUFHLEVBQUVDLE1BQU0sS0FBSztRQUMzQ0gsSUFBSSxDQUFDLENBQUM7UUFDTmIsUUFBUSxDQUFDZSxHQUFHLEVBQUVDLE1BQU0sQ0FBQztNQUN2QixDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7RUFDSjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLFFBQVFBLENBQUNQLElBQUksRUFBRUMsR0FBRyxFQUFFWCxRQUFRLEVBQUU7SUFDNUJqQyxXQUFXLENBQUM2QyxHQUFHLENBQUVDLElBQUksSUFBSztNQUN4QixJQUFJLENBQUNLLFNBQVMsQ0FBQ1IsSUFBSSxFQUFFQyxHQUFHLEVBQUUsQ0FBQ0ksR0FBRyxFQUFFQyxNQUFNLEtBQUs7UUFDekNILElBQUksQ0FBQyxDQUFDO1FBQ05iLFFBQVEsQ0FBQ2UsR0FBRyxFQUFFQyxNQUFNLENBQUM7TUFDdkIsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0VBQ0o7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFRixXQUFXQSxDQUFDSixJQUFJLEVBQUVDLEdBQUcsRUFBRVgsUUFBUSxFQUFFO0lBQy9CLE1BQU1tQixRQUFRLEdBQUcsSUFBSSxDQUFDMUMsU0FBUyxHQUFHLFFBQVEsR0FBRyxRQUFRO0lBRXJELElBQUksQ0FBQyxJQUFJLENBQUNFLFFBQVEsRUFBRTtNQUNsQixNQUFNN0MsR0FBRyxHQUFJLEdBQUVxRixRQUFTLGtCQUFpQjtNQUN6QyxNQUFNQyxVQUFVLEdBQ2QsT0FBTyxJQUFJLENBQUN4QyxNQUFNLENBQUM5QyxHQUFHLENBQUMsS0FBSyxRQUFRLEdBQ2hDa0IsSUFBSSxDQUFDcUUsb0JBQW9CLEdBQ3pCLElBQUksQ0FBQ3pDLE1BQU0sQ0FBQzlDLEdBQUcsQ0FBQztNQUV0QixJQUFJLENBQUM2QyxRQUFRLEdBQUczQixJQUFJLENBQUNzRSxnQkFBZ0IsQ0FBQWpHLGFBQUEsQ0FBQUEsYUFBQSxLQUNoQyxJQUFJLENBQUNpRCxRQUFRLENBQUNpRCxrQkFBa0I7UUFDbkNIO01BQVUsRUFDWCxDQUFDO01BQ0YsSUFBSSxDQUFDekMsUUFBUSxDQUFDakIsa0JBQWtCLENBQUMsR0FBRyxJQUFJO01BQ3hDLElBQUksQ0FBQ2lCLFFBQVEsQ0FBQ2hCLFlBQVksQ0FBQyxHQUFHLENBQUM7TUFDL0IsSUFBSSxDQUFDZ0IsUUFBUSxDQUFDZCxRQUFRLENBQUMsR0FBRyxFQUFFO01BQzVCLElBQUksQ0FBQ2MsUUFBUSxDQUFDNkMsRUFBRSxDQUFDLE9BQU8sRUFBRUMsY0FBYyxDQUFDO01BQ3pDLElBQUksQ0FBQzlDLFFBQVEsQ0FBQzZDLEVBQUUsQ0FBQyxNQUFNLEVBQUVFLGFBQWEsQ0FBQztJQUN6QztJQUVBLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ2YsU0FBUyxDQUFDLEdBQUdvQyxRQUFRO0lBRW5DLElBQUksQ0FBQ3JCLFFBQVEsQ0FBQ2dELEtBQUssQ0FBQ2pCLElBQUksQ0FBQztJQUN6QixJQUFJQyxHQUFHLEVBQUUsSUFBSSxDQUFDaEMsUUFBUSxDQUFDZ0QsS0FBSyxDQUFDbkUsT0FBTyxDQUFDO0lBRXJDLElBQUksQ0FBQ21CLFFBQVEsQ0FBQ2lELEtBQUssQ0FBQyxNQUFNO01BQ3hCLE1BQU1iLEdBQUcsR0FBRyxJQUFJLENBQUNwQyxRQUFRLENBQUNiLE1BQU0sQ0FBQztNQUVqQyxJQUFJaUQsR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDcEMsUUFBUSxDQUFDb0IsS0FBSyxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDcEIsUUFBUSxHQUFHLElBQUk7UUFDcEJxQixRQUFRLENBQUNlLEdBQUcsQ0FBQztRQUNiO01BQ0Y7TUFFQSxNQUFNTCxJQUFJLEdBQUd4RCxVQUFVLENBQUMyRSxNQUFNLENBQzVCLElBQUksQ0FBQ2xELFFBQVEsQ0FBQ2QsUUFBUSxDQUFDLEVBQ3ZCLElBQUksQ0FBQ2MsUUFBUSxDQUFDaEIsWUFBWSxDQUM1QixDQUFDO01BRUQsSUFBSSxJQUFJLENBQUNnQixRQUFRLENBQUNtRCxjQUFjLENBQUNDLFVBQVUsRUFBRTtRQUMzQyxJQUFJLENBQUNwRCxRQUFRLENBQUNvQixLQUFLLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUNwQixRQUFRLEdBQUcsSUFBSTtNQUN0QixDQUFDLE1BQU07UUFDTCxJQUFJLENBQUNBLFFBQVEsQ0FBQ2hCLFlBQVksQ0FBQyxHQUFHLENBQUM7UUFDL0IsSUFBSSxDQUFDZ0IsUUFBUSxDQUFDZCxRQUFRLENBQUMsR0FBRyxFQUFFO1FBRTVCLElBQUk4QyxHQUFHLElBQUksSUFBSSxDQUFDL0IsTUFBTSxDQUFFLEdBQUV1QyxRQUFTLHNCQUFxQixDQUFDLEVBQUU7VUFDekQsSUFBSSxDQUFDeEMsUUFBUSxDQUFDcUQsS0FBSyxDQUFDLENBQUM7UUFDdkI7TUFDRjtNQUVBaEMsUUFBUSxDQUFDLElBQUksRUFBRVUsSUFBSSxDQUFDO0lBQ3RCLENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRVEsU0FBU0EsQ0FBQ1IsSUFBSSxFQUFFQyxHQUFHLEVBQUVYLFFBQVEsRUFBRTtJQUM3QixNQUFNbUIsUUFBUSxHQUFHLElBQUksQ0FBQzFDLFNBQVMsR0FBRyxRQUFRLEdBQUcsUUFBUTtJQUVyRCxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLEVBQUU7TUFDbEIsTUFBTTVDLEdBQUcsR0FBSSxHQUFFcUYsUUFBUyxrQkFBaUI7TUFDekMsTUFBTUMsVUFBVSxHQUNkLE9BQU8sSUFBSSxDQUFDeEMsTUFBTSxDQUFDOUMsR0FBRyxDQUFDLEtBQUssUUFBUSxHQUNoQ2tCLElBQUksQ0FBQ3FFLG9CQUFvQixHQUN6QixJQUFJLENBQUN6QyxNQUFNLENBQUM5QyxHQUFHLENBQUM7TUFFdEIsSUFBSSxDQUFDNEMsUUFBUSxHQUFHMUIsSUFBSSxDQUFDaUYsZ0JBQWdCLENBQUE1RyxhQUFBLENBQUFBLGFBQUEsS0FDaEMsSUFBSSxDQUFDaUQsUUFBUSxDQUFDNEQsa0JBQWtCO1FBQ25DZDtNQUFVLEVBQ1gsQ0FBQztNQUVGLElBQUksQ0FBQzFDLFFBQVEsQ0FBQ2YsWUFBWSxDQUFDLEdBQUcsQ0FBQztNQUMvQixJQUFJLENBQUNlLFFBQVEsQ0FBQ2IsUUFBUSxDQUFDLEdBQUcsRUFBRTtNQUU1QixJQUFJLENBQUNhLFFBQVEsQ0FBQzhDLEVBQUUsQ0FBQyxNQUFNLEVBQUVXLGFBQWEsQ0FBQztJQUN6QztJQUVBLElBQUksQ0FBQ3pELFFBQVEsQ0FBQ2QsU0FBUyxDQUFDLEdBQUdvQyxRQUFRO0lBRW5DLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ2lELEtBQUssQ0FBQ2pCLElBQUksQ0FBQztJQUN6QixJQUFJLENBQUNoQyxRQUFRLENBQUNrRCxLQUFLLENBQUM1RSxJQUFJLENBQUNvRixZQUFZLEVBQUUsTUFBTTtNQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDMUQsUUFBUSxFQUFFO1FBQ2xCO1FBQ0E7UUFDQTtRQUNBO01BQ0Y7TUFFQSxJQUFJZ0MsSUFBSSxHQUFHeEQsVUFBVSxDQUFDMkUsTUFBTSxDQUMxQixJQUFJLENBQUNuRCxRQUFRLENBQUNiLFFBQVEsQ0FBQyxFQUN2QixJQUFJLENBQUNhLFFBQVEsQ0FBQ2YsWUFBWSxDQUM1QixDQUFDO01BRUQsSUFBSWdELEdBQUcsRUFBRTtRQUNQRCxJQUFJLEdBQUcsSUFBSXJELFVBQVUsQ0FBQ3FELElBQUksQ0FBQzJCLE1BQU0sRUFBRTNCLElBQUksQ0FBQzRCLFVBQVUsRUFBRTVCLElBQUksQ0FBQ25GLE1BQU0sR0FBRyxDQUFDLENBQUM7TUFDdEU7O01BRUE7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJLENBQUNtRCxRQUFRLENBQUNkLFNBQVMsQ0FBQyxHQUFHLElBQUk7TUFFL0IsSUFBSSxDQUFDYyxRQUFRLENBQUNmLFlBQVksQ0FBQyxHQUFHLENBQUM7TUFDL0IsSUFBSSxDQUFDZSxRQUFRLENBQUNiLFFBQVEsQ0FBQyxHQUFHLEVBQUU7TUFFNUIsSUFBSThDLEdBQUcsSUFBSSxJQUFJLENBQUMvQixNQUFNLENBQUUsR0FBRXVDLFFBQVMsc0JBQXFCLENBQUMsRUFBRTtRQUN6RCxJQUFJLENBQUN6QyxRQUFRLENBQUNzRCxLQUFLLENBQUMsQ0FBQztNQUN2QjtNQUVBaEMsUUFBUSxDQUFDLElBQUksRUFBRVUsSUFBSSxDQUFDO0lBQ3RCLENBQUMsQ0FBQztFQUNKO0FBQ0Y7QUFFQTZCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHeEUsaUJBQWlCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTbUUsYUFBYUEsQ0FBQ00sS0FBSyxFQUFFO0VBQzVCLElBQUksQ0FBQzVFLFFBQVEsQ0FBQyxDQUFDMUMsSUFBSSxDQUFDc0gsS0FBSyxDQUFDO0VBQzFCLElBQUksQ0FBQzlFLFlBQVksQ0FBQyxJQUFJOEUsS0FBSyxDQUFDbEgsTUFBTTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTbUcsYUFBYUEsQ0FBQ2UsS0FBSyxFQUFFO0VBQzVCLElBQUksQ0FBQzlFLFlBQVksQ0FBQyxJQUFJOEUsS0FBSyxDQUFDbEgsTUFBTTtFQUVsQyxJQUNFLElBQUksQ0FBQ21DLGtCQUFrQixDQUFDLENBQUNXLFdBQVcsR0FBRyxDQUFDLElBQ3hDLElBQUksQ0FBQ1YsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQyxDQUFDVyxXQUFXLEVBQzFEO0lBQ0EsSUFBSSxDQUFDUixRQUFRLENBQUMsQ0FBQzFDLElBQUksQ0FBQ3NILEtBQUssQ0FBQztJQUMxQjtFQUNGO0VBRUEsSUFBSSxDQUFDM0UsTUFBTSxDQUFDLEdBQUcsSUFBSTRFLFVBQVUsQ0FBQywyQkFBMkIsQ0FBQztFQUMxRCxJQUFJLENBQUM1RSxNQUFNLENBQUMsQ0FBQzZFLElBQUksR0FBRyxtQ0FBbUM7RUFDdkQsSUFBSSxDQUFDN0UsTUFBTSxDQUFDLENBQUNWLFdBQVcsQ0FBQyxHQUFHLElBQUk7RUFDaEMsSUFBSSxDQUFDd0YsY0FBYyxDQUFDLE1BQU0sRUFBRWxCLGFBQWEsQ0FBQztFQUMxQyxJQUFJLENBQUNNLEtBQUssQ0FBQyxDQUFDO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU1AsY0FBY0EsQ0FBQ1YsR0FBRyxFQUFFO0VBQzNCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxDQUFDckQsa0JBQWtCLENBQUMsQ0FBQ2lCLFFBQVEsR0FBRyxJQUFJO0VBQ3hDb0MsR0FBRyxDQUFDM0QsV0FBVyxDQUFDLEdBQUcsSUFBSTtFQUN2QixJQUFJLENBQUNRLFNBQVMsQ0FBQyxDQUFDbUQsR0FBRyxDQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanM/YzE3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJ6bGliIiwicmVxdWlyZSIsImJ1ZmZlclV0aWwiLCJMaW1pdGVyIiwia1N0YXR1c0NvZGUiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwic3BlY2llcyIsIlRSQUlMRVIiLCJmcm9tIiwia1Blck1lc3NhZ2VEZWZsYXRlIiwia1RvdGFsTGVuZ3RoIiwia0NhbGxiYWNrIiwia0J1ZmZlcnMiLCJrRXJyb3IiLCJ6bGliTGltaXRlciIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaXNTZXJ2ZXIiLCJtYXhQYXlsb2FkIiwiX21heFBheWxvYWQiLCJfb3B0aW9ucyIsIl90aHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJfaXNTZXJ2ZXIiLCJfZGVmbGF0ZSIsIl9pbmZsYXRlIiwicGFyYW1zIiwiY29uY3VycmVuY3kiLCJjb25jdXJyZW5jeUxpbWl0IiwiZXh0ZW5zaW9uTmFtZSIsIm9mZmVyIiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciIsImNsaWVudE5vQ29udGV4dFRha2VvdmVyIiwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwic2VydmVyX21heF93aW5kb3dfYml0cyIsImNsaWVudE1heFdpbmRvd0JpdHMiLCJjbGllbnRfbWF4X3dpbmRvd19iaXRzIiwiYWNjZXB0IiwiY29uZmlndXJhdGlvbnMiLCJub3JtYWxpemVQYXJhbXMiLCJhY2NlcHRBc1NlcnZlciIsImFjY2VwdEFzQ2xpZW50IiwiY2xlYW51cCIsImNsb3NlIiwiY2FsbGJhY2siLCJFcnJvciIsIm9mZmVycyIsIm9wdHMiLCJhY2NlcHRlZCIsImZpbmQiLCJyZXNwb25zZSIsIm51bSIsImlzSW50ZWdlciIsImRlY29tcHJlc3MiLCJkYXRhIiwiZmluIiwiYWRkIiwiZG9uZSIsIl9kZWNvbXByZXNzIiwiZXJyIiwicmVzdWx0IiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJjb25jYXQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZXNldCIsImNyZWF0ZURlZmxhdGVSYXciLCJ6bGliRGVmbGF0ZU9wdGlvbnMiLCJkZWZsYXRlT25EYXRhIiwiWl9TWU5DX0ZMVVNIIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsIlJhbmdlRXJyb3IiLCJjb2RlIiwicmVtb3ZlTGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Writable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      cb(error);\n      return;\n    }\n    const compressed = (buf[0] & 0x40) === 0x40;\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      cb(error);\n      return;\n    }\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (!this._fragmented) {\n        const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n        cb(error);\n        return;\n      }\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      cb(error);\n      return;\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n      cb(error);\n      return;\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n      cb(error);\n      return;\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n        cb(error);\n        return;\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n          cb(error);\n          return;\n        }\n        this._fragments.push(buf);\n      }\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n    if (this._opcode === 2) {\n      let data;\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        cb(error);\n        return;\n      }\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n          cb(error);\n          return;\n        }\n        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n          cb(error);\n          return;\n        }\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n      this._state = GET_INFO;\n      return;\n    }\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\nmodule.exports = Receiver;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBUyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUV0QyxNQUFNQyxpQkFBaUIsR0FBR0QsbUJBQU8sQ0FBQywrRUFBc0IsQ0FBQztBQUN6RCxNQUFNO0VBQ0pFLFlBQVk7RUFDWkMsWUFBWTtFQUNaQyxXQUFXO0VBQ1hDO0FBQ0YsQ0FBQyxHQUFHTCxtQkFBTyxDQUFDLDZEQUFhLENBQUM7QUFDMUIsTUFBTTtFQUFFTSxNQUFNO0VBQUVDLGFBQWE7RUFBRUM7QUFBTyxDQUFDLEdBQUdSLG1CQUFPLENBQUMsaUVBQWUsQ0FBQztBQUNsRSxNQUFNO0VBQUVTLGlCQUFpQjtFQUFFQztBQUFZLENBQUMsR0FBR1YsbUJBQU8sQ0FBQywrREFBYyxDQUFDO0FBRWxFLE1BQU1XLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNDLE9BQU8sQ0FBQztBQUV6QyxNQUFNQyxRQUFRLEdBQUcsQ0FBQztBQUNsQixNQUFNQyxxQkFBcUIsR0FBRyxDQUFDO0FBQy9CLE1BQU1DLHFCQUFxQixHQUFHLENBQUM7QUFDL0IsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsU0FBUyxHQUFHLENBQUM7QUFDbkIsTUFBTUMsV0FBVyxHQUFHLENBQUM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxRQUFRLFNBQVN2QixRQUFRLENBQUM7RUFDOUI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXdCLFdBQVdBLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN4QixLQUFLLENBQUMsQ0FBQztJQUVQLElBQUksQ0FBQ0MsdUJBQXVCLEdBQzFCRCxP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LENBQUNDLE9BQU8sR0FBR3RGLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzPzA5NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIl0sIm5hbWVzIjpbIldyaXRhYmxlIiwicmVxdWlyZSIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiY29uY2F0IiwidG9BcnJheUJ1ZmZlciIsInVubWFzayIsImlzVmFsaWRTdGF0dXNDb2RlIiwiaXNWYWxpZFVURjgiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsIkdFVF9JTkZPIiwiR0VUX1BBWUxPQURfTEVOR1RIXzE2IiwiR0VUX1BBWUxPQURfTEVOR1RIXzY0IiwiR0VUX01BU0siLCJHRVRfREFUQSIsIklORkxBVElORyIsIkRFRkVSX0VWRU5UIiwiUmVjZWl2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJ1bmRlZmluZWQiLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlciIsIl9tYXhQYXlsb2FkIiwibWF4UGF5bG9hZCIsIl9za2lwVVRGOFZhbGlkYXRpb24iLCJza2lwVVRGOFZhbGlkYXRpb24iLCJfYnVmZmVyZWRCeXRlcyIsIl9idWZmZXJzIiwiX2NvbXByZXNzZWQiLCJfcGF5bG9hZExlbmd0aCIsIl9tYXNrIiwiX2ZyYWdtZW50ZWQiLCJfbWFza2VkIiwiX2ZpbiIsIl9vcGNvZGUiLCJfdG90YWxQYXlsb2FkTGVuZ3RoIiwiX21lc3NhZ2VMZW5ndGgiLCJfZnJhZ21lbnRzIiwiX2Vycm9yZWQiLCJfbG9vcCIsIl9zdGF0ZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImxlbmd0aCIsInB1c2giLCJzdGFydExvb3AiLCJjb25zdW1lIiwibiIsInNoaWZ0IiwiYnVmIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImRzdCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImVycm9yIiwiY3JlYXRlRXJyb3IiLCJSYW5nZUVycm9yIiwiY29tcHJlc3NlZCIsImV4dGVuc2lvbk5hbWUiLCJoYXZlTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwibnVtIiwicmVhZFVJbnQzMkJFIiwiTWF0aCIsInBvdyIsImRhdGEiLCJjb250cm9sTWVzc2FnZSIsImRlY29tcHJlc3MiLCJkYXRhTWVzc2FnZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXJyIiwibWVzc2FnZUxlbmd0aCIsImZyYWdtZW50cyIsIkJsb2IiLCJlbWl0Iiwic2V0SW1tZWRpYXRlIiwiRXJyb3IiLCJlbmQiLCJjb2RlIiwiRXJyb3JDdG9yIiwibWVzc2FnZSIsInByZWZpeCIsInN0YXR1c0NvZGUiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while the blob was being read\");\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === \"function\") cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxFQUFFbkIsR0FBRyxFQUFFM0IsRUFBRTtJQUM5QitCLGNBQWNlLFFBQVFuQixLQUFLM0I7SUFDM0I4QyxPQUFPcEUsT0FBTyxDQUFDaUQ7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcz82YjhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSLCBrV2ViU29ja2V0LCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBSQU5ET01fUE9PTF9TSVpFID0gOCAqIDEwMjQ7XG5sZXQgcmFuZG9tUG9vbDtcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XG5cbmNvbnN0IERFRkFVTFQgPSAwO1xuY29uc3QgREVGTEFUSU5HID0gMTtcbmNvbnN0IEdFVF9CTE9CX0RBVEEgPSAyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICB0aGlzLm9uZXJyb3IgPSBOT09QO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICBpZiAocmFuZG9tUG9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcbiAgICAgICAgICAgIC8vIGJlIG1hc2tlZCBzbyBpdCBtYXkgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIHJhbmRvbVBvb2xQb2ludGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcblxuICAgIGJsb2JcbiAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayB0byBlbnN1cmUgdGhhdCBlcnJvcnNcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYG9uRXJyb3JgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIGZvciB0aGUgc2FtZSByZWFzb24gdGhhdFxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG4gICAgICAgIC8vXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sob25FcnJvciwgdGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBERUZMQVRJTkc7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuXG4vKipcbiAqIENhbGxzIHF1ZXVlZCBjYWxsYmFja3Mgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZW5kZXIuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLl9xdWV1ZVtpXTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhIGBTZW5kZXJgIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBwZW5kaW5nIGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvbkVycm9yKHNlbmRlciwgZXJyLCBjYikge1xuICBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYik7XG4gIHNlbmRlci5vbmVycm9yKGVycik7XG59XG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsInJhbmRvbUZpbGxTeW5jIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFTVBUWV9CVUZGRVIiLCJrV2ViU29ja2V0IiwiTk9PUCIsImlzQmxvYiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJSQU5ET01fUE9PTF9TSVpFIiwicmFuZG9tUG9vbCIsInJhbmRvbVBvb2xQb2ludGVyIiwiREVGQVVMVCIsIkRFRkxBVElORyIsIkdFVF9CTE9CX0RBVEEiLCJTZW5kZXIiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJnZW5lcmF0ZU1hc2siLCJfZXh0ZW5zaW9ucyIsIl9nZW5lcmF0ZU1hc2siLCJfbWFza0J1ZmZlciIsIl9zb2NrZXQiLCJfZmlyc3RGcmFnbWVudCIsIl9jb21wcmVzcyIsIl9idWZmZXJlZEJ5dGVzIiwiX3F1ZXVlIiwiX3N0YXRlIiwib25lcnJvciIsInVuZGVmaW5lZCIsImZyYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJtZXJnZSIsIm9mZnNldCIsInNraXBNYXNraW5nIiwiZGF0YUxlbmd0aCIsImZyb20iLCJsZW5ndGgiLCJyZWFkT25seSIsInBheWxvYWRMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsIlR5cGVFcnJvciIsImJ5dGVMZW5ndGgiLCJSYW5nZUVycm9yIiwid3JpdGUiLCJzZXQiLCJlbnF1ZXVlIiwiZGlzcGF0Y2giLCJzZW5kRnJhbWUiLCJwaW5nIiwic2l6ZSIsImdldEJsb2JEYXRhIiwicG9uZyIsInNlbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImV4dGVuc2lvbk5hbWUiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBhcmFtcyIsIl9pc1NlcnZlciIsIl90aHJlc2hvbGQiLCJvcHRzIiwiYmxvYiIsImFycmF5QnVmZmVyIiwidGhlbiIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbENhbGxiYWNrcyIsImRlcXVldWUiLCJjYXRjaCIsIm9uRXJyb3IiLCJfIiwic2hpZnQiLCJSZWZsZWN0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwiY29yayIsInVuY29yayIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZW5kZXIiLCJpIiwiY2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex(_objectSpread(_objectSpread({}, options), {}, {\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  }));\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\nmodule.exports = createWebSocketStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ29CLFVBQVUsS0FBS3BCLEVBQUUsQ0FBQzJCLFVBQVUsRUFBRTtNQUNuQzNCLEVBQUUsQ0FBQ2UsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTYSxJQUFJQSxDQUFBLEVBQUc7UUFDOUJ6QixNQUFNLENBQUNnQyxNQUFNLENBQUNDLEtBQUssRUFBRUMsUUFBUSxFQUFFbEIsUUFBUSxDQUFDO01BQzFDLENBQUMsQ0FBQztNQUNGO0lBQ0Y7SUFFQW5CLEVBQUUsQ0FBQ3NDLElBQUksQ0FBQ0YsS0FBSyxFQUFFakIsUUFBUSxDQUFDO0VBQzFCLENBQUM7RUFFRGhCLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEtBQUssRUFBRWpCLFdBQVcsQ0FBQztFQUM3QmEsTUFBTSxDQUFDSSxFQUFFLENBQUMsT0FBTyxFQUFFWixhQUFhLENBQUM7RUFDakMsT0FBT1EsTUFBTTtBQUNmO0FBRUFvQyxNQUFNLENBQUNDLE9BQU8sR0FBR3pDLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb3dzdGF0ZS1jYXRhbHlzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzP2NhOTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiRHVwbGV4IiwicmVxdWlyZSIsImVtaXRDbG9zZSIsInN0cmVhbSIsImVtaXQiLCJkdXBsZXhPbkVuZCIsImRlc3Ryb3llZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJkZXN0cm95IiwiZHVwbGV4T25FcnJvciIsImVyciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIndzIiwib3B0aW9ucyIsInRlcm1pbmF0ZU9uRGVzdHJveSIsImR1cGxleCIsImF1dG9EZXN0cm95Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm9uIiwibWVzc2FnZSIsIm1zZyIsImlzQmluYXJ5IiwiZGF0YSIsIl9yZWFkYWJsZVN0YXRlIiwidG9TdHJpbmciLCJwYXVzZSIsIm9uY2UiLCJlcnJvciIsImNsb3NlIiwiX2Rlc3Ryb3kiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsZWQiLCJ0ZXJtaW5hdGUiLCJfZmluYWwiLCJDT05ORUNUSU5HIiwib3BlbiIsIl9zb2NrZXQiLCJlbmRFbWl0dGVkIiwiZmluaXNoIiwiX3JlYWQiLCJpc1BhdXNlZCIsInJlc3VtZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJzZW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1) end = i;\n      const protocol = header.slice(start, end);\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nmodule.exports = {\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBVyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsK0RBQWMsQ0FBQzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxLQUFLQSxDQUFDQyxNQUFNLEVBQUU7RUFDckIsTUFBTUMsU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQzNCLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0VBQ1osSUFBSUMsQ0FBQyxHQUFHLENBQUM7RUFFVCxLQUFLQSxDQUFDLEVBQUVBLENBQUMsR0FBR0wsTUFBTSxDQUFDTSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQzlCLE1BQU1FLElBQUksR0FBR1AsTUFBTSxDQUFDUSxVQUFVLENBQUNILENBQUMsQ0FBQztJQUVqQyxJQUFJRCxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUlQLFVBQVUsQ0FBQ1UsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO01BQ3hDLElBQUlKLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRUEsS0FBSyxHQUFHRSxDQUFDO0lBQzdCLENBQUMsTUFBTSxJQUNMQSxDQUFDLEtBQUssQ0FBQyxLQUNORSxJQUFJLEtBQUssSUFBSSxDQUFDLGFBQWFBLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxZQUMzQztNQUNBLElBQUlILEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSUQsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFQyxHQUFHLEdBQUdDLENBQUM7SUFDekMsQ0FBQyxNQUFNLElBQUlFLElBQUksS0FBSyxJQUFJLENBQUMsV0FBVztNQUNsQyxJQUFJSixLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDaEIsTUFBTSxJQUFJTSxXQUFXLENBQUUsaUNBQWdDSixDQUFFLEVBQUMsQ0FBQztNQUM3RDtNQUVBLElBQUlELEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRUEsR0FBRyxHQUFHQyxDQUFDO01BRXZCLE1BQU1LLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUMsR0FBRyxDQUFDO01BRXpDLElBQUlILFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtRQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO01BQ3RFO01BRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7TUFDdkJQLEtBQUssR0FBR0MsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNsQixDQUFDLE1BQU07TUFDTCxNQUFNLElBQUlLLFdBQVcsQ0FBRSxpQ0FBZ0NKLENBQUUsRUFBQyxDQUFDO0lBQzdEO0VBQ0Y7RUFFQSxJQUFJRixLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUlDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUM5QixNQUFNLElBQUlLLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQztFQUNsRDtFQUVBLE1BQU1DLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUUsQ0FBQyxDQUFDO0VBRXZDLElBQUlKLFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtJQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO0VBQ3RFO0VBRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7RUFDdkIsT0FBT1QsU0FBUztBQUNsQjtBQUVBYSxNQUFNLENBQUNDLE9BQU8sR0FBRztFQUFFaEI7QUFBTSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcz9hZWIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpICE9PSAwICYmXG4gICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcblxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICB9XG5cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicGFyc2UiLCJoZWFkZXIiLCJwcm90b2NvbHMiLCJTZXQiLCJzdGFydCIsImVuZCIsImkiLCJsZW5ndGgiLCJjb2RlIiwiY2hhckNvZGVBdCIsIlN5bnRheEVycm9yIiwicHJvdG9jb2wiLCJzbGljZSIsImhhcyIsImFkZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  isUtf8\n} = __webpack_require__(/*! buffer */ \"buffer\");\nconst {\n  hasBlob\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n// 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return hasBlob && typeof value === 'object' && typeof value.arrayBuffer === 'function' && typeof value.type === 'string' && typeof value.stream === 'function' && (value[Symbol.toStringTag] === 'Blob' || value[Symbol.toStringTag] === 'File');\n}\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTTtFQUFFQTtBQUFPLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyxzQkFBUSxDQUFDO0FBRXBDLE1BQU07RUFBRUM7QUFBUSxDQUFDLEdBQUdELG1CQUFPLENBQUMsNkRBQWEsQ0FBQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsVUFBVSxHQUFHLENBQ2pCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBQSxDQUNoRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLGlCQUFpQkEsQ0FBQ0MsSUFBSSxFQUFFO0VBQy9CLE9BQ0dBLElBQUksSUFBSSxJQUFJLElBQ1hBLElBQUksSUFBSSxJQUFJLElBQ1pBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2RB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dmFsaWRhdGlvbi5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaGFzQmxvYiAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxuICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCbG9iLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc1V0ZjgiLCJyZXF1aXJlIiwiaGFzQmxvYiIsInRva2VuQ2hhcnMiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImNvZGUiLCJfaXNWYWxpZFVURjgiLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJpIiwiaXNCbG9iIiwidmFsdWUiLCJhcnJheUJ1ZmZlciIsInR5cGUiLCJzdHJlYW0iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1ZhbGlkVVRGOCIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19VVEZfOF9WQUxJREFURSIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\nconst {\n  GUID,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = _objectSpread({\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket\n    }, options);\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once('close', cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = _objectSpread({\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message)\n  }, headers);\n  socket.once('finish', socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBQUEsU0FBQUEsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBLFFBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxJQUFBLENBQUFKLENBQUEsT0FBQUcsTUFBQSxDQUFBRSxxQkFBQSxRQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQUwsQ0FBQSxHQUFBQyxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFOLENBQUEsV0FBQUUsTUFBQSxDQUFBSyx3QkFBQSxDQUFBUixDQUFBLEVBQUFDLENBQUEsRUFBQVEsVUFBQSxPQUFBUCxDQUFBLENBQUFRLElBQUEsQ0FBQUMsS0FBQSxDQUFBVCxDQUFBLEVBQUFJLENBQUEsWUFBQUosQ0FBQTtBQUFBLFNBQUFVLGNBQUFaLENBQUEsYUFBQUMsQ0FBQSxNQUFBQSxDQUFBLEdBQUFZLFNBQUEsQ0FBQUMsTUFBQSxFQUFBYixDQUFBLFVBQUFDLENBQUEsV0FBQVcsU0FBQSxDQUFBWixDQUFBLElBQUFZLFNBQUEsQ0FBQVosQ0FBQSxRQUFBQSxDQUFBLE9BQUFGLE9BQUEsQ0FBQUksTUFBQSxDQUFBRCxDQUFBLE9BQUFhLE9BQUEsV0FBQWQsQ0FBQSxJQUFBZSxlQUFBLENBQUFoQixDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxDQUFBRCxDQUFBLFNBQUFFLE1BQUEsQ0FBQWMseUJBQUEsR0FBQWQsTUFBQSxDQUFBZSxnQkFBQSxDQUFBbEIsQ0FBQSxFQUFBRyxNQUFBLENBQUFjLHlCQUFBLENBQUFmLENBQUEsS0FBQUgsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsR0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFFLE1BQUEsQ0FBQWdCLGNBQUEsQ0FBQW5CLENBQUEsRUFBQUMsQ0FBQSxFQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFOLENBQUEsRUFB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RCxPQUFPLENBQUM7RUFFckNsRCxNQUFNLENBQUNWLEdBQUcsQ0FDUCxZQUFXeUQsSUFBSyxJQUFHOUYsSUFBSSxDQUFDbUMsWUFBWSxDQUFDMkQsSUFBSSxDQUFFLE1BQUssR0FDL0NwSSxNQUFNLENBQUNDLElBQUksQ0FBQzRHLE9BQU8sQ0FBQyxDQUNqQjhDLEdBQUcsQ0FBRU0sQ0FBQyxJQUFNLEdBQUVBLENBQUUsS0FBSXBELE9BQU8sQ0FBQ29ELENBQUMsQ0FBRSxFQUFDLENBQUMsQ0FDakNiLElBQUksQ0FBQyxNQUFNLENBQUMsR0FDZixVQUFVLEdBQ1ZwQyxPQUNKLENBQUM7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsaUNBQWlDQSxDQUFDaEQsTUFBTSxFQUFFTSxHQUFHLEVBQUVjLE1BQU0sRUFBRStDLElBQUksRUFBRXBCLE9BQU8sRUFBRTtFQUM3RSxJQUFJL0MsTUFBTSxDQUFDaUcsYUFBYSxDQUFDLGVBQWUsQ0FBQyxFQUFFO0lBQ3pDLE1BQU0xQyxHQUFHLEdBQUcsSUFBSTNCLEtBQUssQ0FBQ21CLE9BQU8sQ0FBQztJQUM5Qm5CLEtBQUssQ0FBQ3NFLGlCQUFpQixDQUFDM0MsR0FBRyxFQUFFUCxpQ0FBaUMsQ0FBQztJQUUvRGhELE1BQU0sQ0FBQ2EsSUFBSSxDQUFDLGVBQWUsRUFBRTBDLEdBQUcsRUFBRW5DLE1BQU0sRUFBRWQsR0FBRyxDQUFDO0VBQ2hELENBQUMsTUFBTTtJQUNMNkMsY0FBYyxDQUFDL0IsTUFBTSxFQUFFK0MsSUFBSSxFQUFFcEIsT0FBTyxDQUFDO0VBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanM/MDEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cCIsIkR1cGxleCIsImNyZWF0ZUhhc2giLCJleHRlbnNpb24iLCJQZXJNZXNzYWdlRGVmbGF0ZSIsInN1YnByb3RvY29sIiwiV2ViU29ja2V0IiwiR1VJRCIsImtXZWJTb2NrZXQiLCJrZXlSZWdleCIsIlJVTk5JTkciLCJDTE9TSU5HIiwiQ0xPU0VEIiwiV2ViU29ja2V0U2VydmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhbGxvd1N5bmNocm9ub3VzRXZlbnRzIiwiYXV0b1BvbmciLCJtYXhQYXlsb2FkIiwic2tpcFVURjhWYWxpZGF0aW9uIiwicGVyTWVzc2FnZURlZmxhdGUiLCJoYW5kbGVQcm90b2NvbHMiLCJjbGllbnRUcmFja2luZyIsInZlcmlmeUNsaWVudCIsIm5vU2VydmVyIiwiYmFja2xvZyIsInNlcnZlciIsImhvc3QiLCJwYXRoIiwicG9ydCIsIl9zZXJ2ZXIiLCJjcmVhdGVTZXJ2ZXIiLCJyZXEiLCJib2R5IiwiU1RBVFVTX0NPREVTIiwid3JpdGVIZWFkIiwiZW5kIiwibGlzdGVuIiwiZW1pdENvbm5lY3Rpb24iLCJlbWl0IiwiYmluZCIsIl9yZW1vdmVMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lcnMiLCJsaXN0ZW5pbmciLCJlcnJvciIsInVwZ3JhZGUiLCJzb2NrZXQiLCJoZWFkIiwiaGFuZGxlVXBncmFkZSIsImNsaWVudHMiLCJTZXQiLCJfc2hvdWxkRW1pdENsb3NlIiwiX3N0YXRlIiwiYWRkcmVzcyIsIkVycm9yIiwiY2xvc2UiLCJjYiIsIm9uY2UiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0Q2xvc2UiLCJzaXplIiwic2hvdWxkSGFuZGxlIiwiaW5kZXgiLCJ1cmwiLCJpbmRleE9mIiwicGF0aG5hbWUiLCJzbGljZSIsIm9uIiwic29ja2V0T25FcnJvciIsImhlYWRlcnMiLCJ2ZXJzaW9uIiwibWV0aG9kIiwibWVzc2FnZSIsImFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvciIsInRvTG93ZXJDYXNlIiwidGVzdCIsImFib3J0SGFuZHNoYWtlIiwic2VjV2ViU29ja2V0UHJvdG9jb2wiLCJwcm90b2NvbHMiLCJwYXJzZSIsImVyciIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwib2ZmZXJzIiwiZXh0ZW5zaW9uTmFtZSIsImFjY2VwdCIsImluZm8iLCJvcmlnaW4iLCJzZWN1cmUiLCJhdXRob3JpemVkIiwiZW5jcnlwdGVkIiwidmVyaWZpZWQiLCJjb2RlIiwiY29tcGxldGVVcGdyYWRlIiwicmVhZGFibGUiLCJkZXN0cm95IiwiZGlnZXN0IiwidXBkYXRlIiwid3MiLCJwcm90b2NvbCIsInZhbHVlcyIsIm5leHQiLCJfcHJvdG9jb2wiLCJwYXJhbXMiLCJmb3JtYXQiLCJfZXh0ZW5zaW9ucyIsIndyaXRlIiwiY29uY2F0Iiwiam9pbiIsInJlbW92ZUxpc3RlbmVyIiwic2V0U29ja2V0IiwiYWRkIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1hcCIsImV2ZW50IiwicmVtb3ZlTGlzdGVuZXJzIiwiQ29ubmVjdGlvbiIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJoIiwibGlzdGVuZXJDb3VudCIsImNhcHR1cmVTdGFja1RyYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst {\n  randomBytes,\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst {\n  Duplex,\n  Readable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  URL\n} = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/ws/lib/sender.js\");\nconst {\n  isBlob\n} = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = __webpack_require__(/*! ./event-target */ \"(ssr)/./node_modules/ws/lib/event-target.js\");\nconst {\n  format,\n  parse\n} = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\nconst {\n  toBuffer\n} = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = _objectSpread({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = _objectSpread(_objectSpread({\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10\n  }, options), {}, {\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n  websocket._autoPong = opts.autoPong;\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n  websocket._url = parsedUrl.href;\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = _objectSpread(_objectSpread({}, opts.headers), {}, {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  });\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        headers: {}\n      });\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n    req = websocket._req = request(opts);\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n  req.on('error', err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const upgrade = res.headers.upgrade;\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n  websocket._receiver.end();\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFBQSxTQUFBQSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFlLGVBQUEsQ0FBQWhCLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYyx5QkFBQSxHQUFBZCxNQUFBLENBQUFlLGdCQUFBLENBQUFsQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWMseUJBQUEsQ0FBQWYsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZ0IsY0FBQSxDQUFBbkIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQU4sQ0FBQSxFQUFBRCxDQUFB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b2NrZXQuanM/M2Q5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXh8UmVhZGFibGUkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBEdXBsZXgsIFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3QgeyBpc0Jsb2IgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlELFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZSxcbiAga0xpc3RlbmVyLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldCxcbiAgTk9PUFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7XG4gIEV2ZW50VGFyZ2V0OiB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfVxufSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCB7IHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbmNvbnN0IGtBYm9ydGVkID0gU3ltYm9sKCdrQWJvcnRlZCcpO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSBFTVBUWV9CVUZGRVI7XG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb3RvY29sID0gJyc7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG5cbiAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwO1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZGlyZWN0cyA9IDA7XG5cbiAgICAgIGlmIChwcm90b2NvbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b1BvbmcgPSBvcHRpb25zLmF1dG9Qb25nO1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG5cbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc2VuZGVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XG5cbiAgICAvL1xuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxuICAgIC8vXG4gICAgaWYgKHNvY2tldC5zZXRUaW1lb3V0KSBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldENsb3NlVGltZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnaXNQYXVzZWQnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0KGhhbmRsZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBhbnlcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXG4gKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICogICAgIGN1c3RvbWl6ZSB0aGUgaGVhZGVycyBvZiBlYWNoIGh0dHAgcmVxdWVzdCBiZWZvcmUgaXQgaXMgc2VudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG4gICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxuICAgIGhvc3RuYW1lOiB1bmRlZmluZWQsXG4gICAgcHJvdG9jb2w6IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIHdlYnNvY2tldC5fYXV0b1BvbmcgPSBvcHRzLmF1dG9Qb25nO1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzOic7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3c3M6JztcbiAgfVxuXG4gIHdlYnNvY2tldC5fdXJsID0gcGFyc2VkVXJsLmhyZWY7XG5cbiAgY29uc3QgaXNTZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3c3M6JztcbiAgY29uc3QgaXNJcGNVcmwgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG4gIGxldCBpbnZhbGlkVXJsTWVzc2FnZTtcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzSXBjVXJsKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPVxuICAgICAgJ1RoZSBVUkxcXCdzIHByb3RvY29sIG11c3QgYmUgb25lIG9mIFwid3M6XCIsIFwid3NzOlwiLCAnICtcbiAgICAgICdcImh0dHA6XCIsIFwiaHR0cHNcIiwgb3IgXCJ3cyt1bml4OlwiJztcbiAgfSBlbHNlIGlmIChpc0lwY1VybCAmJiAhcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSAnVGhlIFVSTCBjb250YWlucyBhIGZyYWdtZW50IGlkZW50aWZpZXInO1xuICB9XG5cbiAgaWYgKGludmFsaWRVcmxNZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCByZXF1ZXN0ID0gaXNTZWN1cmUgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuICBjb25zdCBwcm90b2NvbFNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9XG4gICAgb3B0cy5jcmVhdGVDb25uZWN0aW9uIHx8IChpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0KTtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAuLi5vcHRzLmhlYWRlcnMsXG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCdcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8XG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xuICAgIH1cblxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNJcGNVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBsZXQgcmVxO1xuXG4gIGlmIChvcHRzLmZvbGxvd1JlZGlyZWN0cykge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbElwYyA9IGlzSXBjVXJsO1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSA9IGlzU2VjdXJlO1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGggPSBpc0lwY1VybFxuICAgICAgICA/IG9wdHMuc29ja2V0UGF0aFxuICAgICAgICA6IHBhcnNlZFVybC5ob3N0O1xuXG4gICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnM7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHVzZXIgcHJvdmlkZWQgb3B0aW9ucyBzbyB0aGF0IGhlYWRlcnMgY2FuIGJlIGNoYW5nZWRcbiAgICAgIC8vIHdpdGhvdXQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgIC8vXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7fSB9O1xuXG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2Vic29ja2V0Lmxpc3RlbmVyQ291bnQoJ3JlZGlyZWN0JykgPT09IDApIHtcbiAgICAgIGNvbnN0IGlzU2FtZUhvc3QgPSBpc0lwY1VybFxuICAgICAgICA/IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IG9wdHMuc29ja2V0UGF0aCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGhcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIDogd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcblxuICAgICAgaWYgKCFpc1NhbWVIb3N0IHx8ICh3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlICYmICFpc1NlY3VyZSkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIGRyb3AgdGhlIGZvbGxvd2luZyBoZWFkZXJzLiBUaGVzZVxuICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cbiAgICAgICAgLy9cbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcblxuICAgICAgICBpZiAoIWlzU2FtZUhvc3QpIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcblxuICAgICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgbWFrZSB0aGUgZmlyc3QgYEF1dGhvcml6YXRpb25gIGhlYWRlciB3aW4uXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcbiAgICAvLyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9XG4gICAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzKSB7XG4gICAgICAvL1xuICAgICAgLy8gVW5saWtlIHdoYXQgaXMgZG9uZSBmb3IgdGhlIGAndXBncmFkZSdgIGV2ZW50LCBubyBlYXJseSBleGl0IGlzXG4gICAgICAvLyB0cmlnZ2VyZWQgaGVyZSBpZiB0aGUgdXNlciBjYWxscyBgd2Vic29ja2V0LmNsb3NlKClgIG9yXG4gICAgICAvLyBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGAncmVkaXJlY3QnYCBldmVudC4gVGhpc1xuICAgICAgLy8gaXMgYmVjYXVzZSB0aGUgdXNlciBjYW4gYWxzbyBjYWxsIGByZXF1ZXN0LmRlc3Ryb3koKWAgd2l0aCBhbiBlcnJvclxuICAgICAgLy8gYmVmb3JlIGNhbGxpbmcgYHdlYnNvY2tldC5jbG9zZSgpYCBvciBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBhbmQgdGhpc1xuICAgICAgLy8gd291bGQgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIGVtaXR0ZWQgb24gdGhlIGByZXF1ZXN0YCBvYmplY3Qgd2l0aCBub1xuICAgICAgLy8gYCdlcnJvcidgIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZC5cbiAgICAgIC8vXG4gICAgICB3ZWJzb2NrZXQuZW1pdCgncmVkaXJlY3QnLCB3ZWJzb2NrZXQudXJsLCByZXEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG4gIH1cblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxW2tBYm9ydGVkXSkgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgIGlmIChcbiAgICAgIGxvY2F0aW9uICYmXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgIHN0YXR1c0NvZGUgPCA0MDBcbiAgICApIHtcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICBsZXQgYWRkcjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2xvY2F0aW9ufWApO1xuICAgICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2UoXG4gICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgcmVxLFxuICAgICAgICBgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2U6ICR7cmVzLnN0YXR1c0NvZGV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHdlYnNvY2tldC5lbWl0KCd1cGdyYWRlJywgcmVzKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIHVzZXIgbWF5IGhhdmUgY2xvc2VkIHRoZSBjb25uZWN0aW9uIGZyb20gYSBsaXN0ZW5lciBvZiB0aGVcbiAgICAvLyBgJ3VwZ3JhZGUnYCBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXMuaGVhZGVycy51cGdyYWRlO1xuXG4gICAgaWYgKHVwZ3JhZGUgPT09IHVuZGVmaW5lZCB8fCB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBkaWdlc3QpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdEVycm9yO1xuXG4gICAgaWYgKHNlcnZlclByb3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBubyBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5fcHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgJ1NlcnZlciBzZW50IGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBidXQgbm8gZXh0ZW5zaW9uICcgK1xuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnNpb25zO1xuXG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcblxuICAgICAgaWYgKFxuICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRzLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBnZW5lcmF0ZU1hc2s6IG9wdHMuZ2VuZXJhdGVNYXNrLFxuICAgICAgbWF4UGF5bG9hZDogb3B0cy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuICB9KTtcblxuICBpZiAob3B0cy5maW5pc2hSZXF1ZXN0KSB7XG4gICAgb3B0cy5maW5pc2hSZXF1ZXN0KHJlcSwgd2Vic29ja2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXEuZW5kKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbWl0IHRoZSBgJ2Vycm9yJ2AgYW5kIGAnY2xvc2UnYCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXNzaWdubWVudCBpcyBwcmFjdGljYWxseSB1c2VsZXNzIGFuZCBpcyBkb25lIG9ubHkgZm9yXG4gIC8vIGNvbnNpc3RlbmN5LlxuICAvL1xuICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbVtrQWJvcnRlZF0gPSB0cnVlO1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuXG4gICAgaWYgKHN0cmVhbS5zb2NrZXQgJiYgIXN0cmVhbS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAvL1xuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgY29tcGxldGVkLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxuICAgICAgLy9cbiAgICAgIHN0cmVhbS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2UsIHdlYnNvY2tldCwgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gaXNCbG9iKGRhdGEpID8gZGF0YS5zaXplIDogdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAoIXdlYnNvY2tldC5pc1BhdXNlZCkgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgICAvL1xuICAgIC8vIE9uIE5vZGUuanMgPCAxNC4wLjAgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIHN5bmNocm9ub3VzbHkuIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxuICAgIC8vXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcbiAgfVxuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSBUaGUgcmVhZGFibGUgc3RyZWFtXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtKSB7XG4gIHN0cmVhbS5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgYFNlbmRlcmAgZXJyb3IgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCk7XG4gIH1cblxuICAvL1xuICAvLyBgc29ja2V0LmVuZCgpYCBpcyB1c2VkIGluc3RlYWQgb2YgYHNvY2tldC5kZXN0cm95KClgIHRvIGFsbG93IHRoZSBvdGhlclxuICAvLyBwZWVyIHRvIGZpbmlzaCBzZW5kaW5nIHF1ZXVlZCBkYXRhLiBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCBhIHRpbWVyIGhlcmVcbiAgLy8gYmVjYXVzZSBgQ0xPU0lOR2AgbWVhbnMgdGhhdCBpdCBpcyBhbHJlYWR5IHNldCBvciBub3QgbmVlZGVkLlxuICAvL1xuICB0aGlzLl9zb2NrZXQuZW5kKCk7XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgdGltZXIgdG8gZGVzdHJveSB0aGUgdW5kZXJseWluZyByYXcgc29ja2V0IG9mIGEgV2ViU29ja2V0LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpIHtcbiAgd2Vic29ja2V0Ll9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95LmJpbmQod2Vic29ja2V0Ll9zb2NrZXQpLFxuICAgIGNsb3NlVGltZW91dFxuICApO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgbGV0IGNodW5rO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cbiAgLy9cbiAgaWYgKFxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXG4gICkge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG5cbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcblxuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzLmVuZCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cbiAgaWYgKHdlYnNvY2tldCkge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cHMiLCJodHRwIiwibmV0IiwidGxzIiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVIYXNoIiwiRHVwbGV4IiwiUmVhZGFibGUiLCJVUkwiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiaXNCbG9iIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmb3JtYXQiLCJwYXJzZSIsInRvQnVmZmVyIiwiY2xvc2VUaW1lb3V0Iiwia0Fib3J0ZWQiLCJwcm90b2NvbFZlcnNpb25zIiwicmVhZHlTdGF0ZXMiLCJzdWJwcm90b2NvbFJlZ2V4IiwiV2ViU29ja2V0IiwiY29uc3RydWN0b3IiLCJhZGRyZXNzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIl9iaW5hcnlUeXBlIiwiX2Nsb3NlQ29kZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfZXJyb3JFbWl0dGVkIiwiX2V4dGVuc2lvbnMiLCJfcGF1c2VkIiwiX3Byb3RvY29sIiwiX3JlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiX3JlY2VpdmVyIiwiX3NlbmRlciIsIl9zb2NrZXQiLCJfYnVmZmVyZWRBbW91bnQiLCJfaXNTZXJ2ZXIiLCJfcmVkaXJlY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5pdEFzQ2xpZW50IiwiX2F1dG9Qb25nIiwiYXV0b1BvbmciLCJiaW5hcnlUeXBlIiwidHlwZSIsImluY2x1ZGVzIiwiYnVmZmVyZWRBbW91bnQiLCJfd3JpdGFibGVTdGF0ZSIsIl9idWZmZXJlZEJ5dGVzIiwiZXh0ZW5zaW9ucyIsImpvaW4iLCJpc1BhdXNlZCIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJyZWNlaXZlciIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJzZW5kZXIiLCJnZW5lcmF0ZU1hc2siLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNlbmRlck9uRXJyb3IiLCJzZXRUaW1lb3V0Iiwic2V0Tm9EZWxheSIsInVuc2hpZnQiLCJzb2NrZXRPbkNsb3NlIiwic29ja2V0T25EYXRhIiwic29ja2V0T25FbmQiLCJzb2NrZXRPbkVycm9yIiwiT1BFTiIsImVtaXQiLCJlbWl0Q2xvc2UiLCJDTE9TRUQiLCJleHRlbnNpb25OYW1lIiwiY2xlYW51cCIsInJlbW92ZUFsbExpc3RlbmVycyIsImNsb3NlIiwiY29kZSIsImRhdGEiLCJtc2ciLCJhYm9ydEhhbmRzaGFrZSIsIl9yZXEiLCJDTE9TSU5HIiwiZXJyb3JFbWl0dGVkIiwiZW5kIiwiZXJyIiwic2V0Q2xvc2VUaW1lciIsInBhdXNlIiwicGluZyIsIm1hc2siLCJjYiIsIkVycm9yIiwidG9TdHJpbmciLCJzZW5kQWZ0ZXJDbG9zZSIsInBvbmciLCJyZXN1bWUiLCJuZWVkRHJhaW4iLCJzZW5kIiwib3B0cyIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZGVzdHJveSIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwic2V0IiwiaGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIndlYnNvY2tldCIsInByb3RvY29sVmVyc2lvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZm9sbG93UmVkaXJlY3RzIiwibWF4UmVkaXJlY3RzIiwic29ja2V0UGF0aCIsImhvc3RuYW1lIiwidGltZW91dCIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlJhbmdlRXJyb3IiLCJwYXJzZWRVcmwiLCJTeW50YXhFcnJvciIsImhyZWYiLCJpc1NlY3VyZSIsImlzSXBjVXJsIiwiaW52YWxpZFVybE1lc3NhZ2UiLCJwYXRobmFtZSIsImhhc2giLCJlbWl0RXJyb3JBbmRDbG9zZSIsImRlZmF1bHRQb3J0IiwicmVxdWVzdCIsInByb3RvY29sU2V0IiwiU2V0IiwiY3JlYXRlQ29ubmVjdGlvbiIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiaGVhZGVycyIsIkNvbm5lY3Rpb24iLCJVcGdyYWRlIiwic2VhcmNoIiwiaGFuZHNoYWtlVGltZW91dCIsIm9mZmVyIiwidGVzdCIsImhhcyIsImFkZCIsIm9yaWdpbiIsIk9yaWdpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwicGFydHMiLCJzcGxpdCIsInJlcSIsIl9vcmlnaW5hbElwYyIsIl9vcmlnaW5hbFNlY3VyZSIsIl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGgiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJsaXN0ZW5lckNvdW50IiwiaXNTYW1lSG9zdCIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJCdWZmZXIiLCJmcm9tIiwibG9jYXRpb24iLCJzdGF0dXNDb2RlIiwiYWJvcnQiLCJhZGRyIiwidXBncmFkZSIsImRpZ2VzdCIsInVwZGF0ZSIsInNlcnZlclByb3QiLCJwcm90RXJyb3IiLCJzaXplIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsIm1lc3NhZ2UiLCJleHRlbnNpb25OYW1lcyIsImFjY2VwdCIsImZpbmlzaFJlcXVlc3QiLCJjb25uZWN0Iiwic2VydmVybmFtZSIsImlzSVAiLCJzdHJlYW0iLCJjYXB0dXJlU3RhY2tUcmFjZSIsInNldEhlYWRlciIsImRlc3Ryb3llZCIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uY2UiLCJiaW5kIiwicmVhc29uIiwicmVjZWl2ZXJPbkZpbmlzaCIsImlzQmluYXJ5IiwiY2h1bmsiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZWFkIiwid3JpdGUiLCJjbGVhclRpbWVvdXQiLCJmaW5pc2hlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  EMPTY_BUFFER\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n  return buf;\n}\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?32c4\");\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil.mask(source, mask, output, offset, length);\n    };\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBYSxDQUFDLEdBQUdDLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUUvQyxNQUFNQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxNQUFNQSxDQUFDQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtFQUNqQyxJQUFJRCxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT1QsWUFBWTtFQUMxQyxJQUFJTyxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT0YsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUVyQyxNQUFNRyxNQUFNLEdBQUdQLE1BQU0sQ0FBQ1EsV0FBVyxDQUFDSCxXQUFXLENBQUM7RUFDOUMsSUFBSUksTUFBTSxHQUFHLENBQUM7RUFFZCxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR04sSUFBSSxDQUFDRSxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFO0lBQ3BDLE1BQU1DLEdBQUcsR0FBR1AsSUFBSSxDQUFDTSxDQUFDLENBQUM7SUFDbkJILE1BQU0sQ0FBQ0ssR0FBRyxDQUFDRCxHQUFHLEVBQUVGLE1BQU0sQ0FBQztJQUN2QkEsTUFBTSxJQUFJRSxHQUFHLENBQUNMLE1BQU07RUFDdEI7RUFFQSxJQUFJRyxNQUFNLEdBQUdKLFdBQVcsRUFBRTtJQUN4QixPQUFPLElBQUlOLFVBQVUsQ0FBQ1EsTUFBTSxDQUFDTSxNQUFNLEVBQUVOLE1BQU0sQ0FBQ08sVUFBVSxFQUFFTCxNQUFNLENBQUM7RUFDakU7RUFFQSxPQUFPRixNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTUSxLQUFLQSxDQUFDQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFVCxNQUFNLEVBQUVILE1BQU0sRUFBRTtFQUNuRCxLQUFLLElBQUlJLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0osTUFBTSxFQUFFSSxDQUFDLEVBQUUsRUFBRTtJQUMvQlEsTUFBTSxDQUFDVCxNQUFNLEdBQUdDLENBQUMsQ0FBQyxHQUFHTSxNQUFNLENBQUNOLENBQUMsQ0FBQyxHQUFHTyxJQUFJLENBQUNQLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDOUM7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNTLE9BQU9BLENBQUNOLE1BQU0sRUFBRUksSUFBSSxFQUFFO0VBQzdCLEtBQUssSUFBSVAsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRyxNQUFNLENBQUNQLE1BQU0sRUFBRUksQ0FBQyxFQUFFLEVBQUU7SUFDdENHLE1BQU0sQ0FBQ0gsQ0FBQyxDQUFDLElBQUlPLElBQUksQ0FBQ1AsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUMxQjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU1UsYUFBYUEsQ0FBQ1QsR0FBRyxFQUFFO0VBQzFCLElBQUlBLEdBQUcsQ0FBQ0wsTUFBTSxLQUFLSyxHQUFHLENBQUNFLE1BQU0sQ0FBQ1EsVUFBVSxFQUFFO0lBQ3hDLE9BQU9WLEdBQUcsQ0FBQ0UsTUFBTTtFQUNuQjtFQUVBLE9BQU9GLEdBQUcsQ0FBQ0UsTUFBTSxDQUFDUyxLQUFLLENBQUNYLEdBQUcsQ0FBQ0csVUFBVSxFQUFFSCxHQUFHLENBQUNHLFVBQVUsR0FBR0gsR0FBRyxDQUFDTCxNQUFNLENBQUM7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNpQixRQUFRQSxDQUFDQyxJQUFJLEVBQUU7RUFDdEJELFFBQVEsQ0FBQ0UsUUFBUSxHQUFHLElBQUk7RUFFeEIsSUFBSXpCLE1BQU0sQ0FBQzBCLFFBQVEsQ0FBQ0YsSUFBSSxDQUFDLEVBQUUsT0FBT0EsSUFBSTtFQUV0QyxJQUFJYixHQUFHO0VBRVAsSUFBSWEsSUFBSSxZQUFZRyxXQUFXLEVBQUU7SUFDL0JoQixHQUFHLEdBQUcsSUFBSVosVUFBVSxDQUFDeUIsSUFBSSxDQUFDO0VBQzVCLENBQUMsTUFBTSxJQUFJRyxXQUFXLENBQUNDLE1BQU0sQ0FBQ0osSUFBSSxDQUFDLEVBQUU7SUFDbkNiLEdBQUcsR0FBRyxJQUFJWixVQUFVLENBQUN5QixJQUFJLENBQUNYLE1BQU0sRUFBRVcsSUFBSSxDQUFDVixVQUFVLEVBQUVVLElBQUksQ0FBQ0gsVUFBVSxDQUFDO0VBQ3JFLENBQUMsTUFBTTtJQUNMVixHQUFHLEdBQUdYLE1BQU0sQ0FBQzZCLElBQUksQ0FBQ0wsSUFBSSxDQUFDO0lBQ3ZCRCxRQUFRLENBQUNFLFFBQVEsR0FBRyxLQUFLO0VBQzNCO0VBRUEsT0FBT2QsR0FBRztBQUNaO0FBRUFtQixNQUFNLENBQUNDLE9BQU8sR0FBRztFQUNmNUIsTUFBTTtFQUNOYyxJQUFJLEVBQUVGLEtBQUs7RUFDWEssYUFBYTtFQUNiRyxRQUFRO0VBQ1JTLE1BQU0sRUFBRWI7QUFDVixDQUFDOztBQUVEO0FBQ0EsSUFBSSxDQUFDYyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0MsaUJBQWlCLEVBQUU7RUFDbEMsSUFBSTtJQUNGLE1BQU1DLFVBQVUsR0FBR3RDLG1CQUFPLENBQUMseUJBQVksQ0FBQztJQUV4Q2dDLG1CQUFtQixHQUFHLFVBQVVkLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVULE1BQU0sRUFBRUgsTUFBTSxFQUFFO01BQ3BFLElBQUlBLE1BQU0sR0FBRyxFQUFFLEVBQUVTLEtBQUssQ0FBQ0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRVQsTUFBTSxFQUFFSCxNQUFNLENBQUMsQ0FBQyxLQUN4RDhCLFVBQVUsQ0FBQ25CLElBQUksQ0FBQ0QsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRVQsTUFBTSxFQUFFSCxNQUFNLENBQUM7SUFDNUQsQ0FBQztJQUVEd0IscUJBQXFCLEdBQUcsVUFBVWpCLE1BQU0sRUFBRUksSUFBSSxFQUFFO01BQzlDLElBQUlKLE1BQU0sQ0FBQ1AsTUFBTSxHQUFHLEVBQUUsRUFBRWEsT0FBTyxDQUFDTixNQUFNLEVBQUVJLElBQUksQ0FBQyxDQUFDLEtBQ3pDbUIsVUFBVSxDQUFDSixNQUFNLENBQUNuQixNQUFNLEVBQUVJLElBQUksQ0FBQztJQUN0QyxDQUFDO0VBQ0gsQ0FBQyxDQUFDLE9BQU9vQixDQUFDLEVBQUU7SUFDVjtFQUFBO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzPzZlMGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25jYXQsXG4gIG1hc2s6IF9tYXNrLFxuICB0b0FycmF5QnVmZmVyLFxuICB0b0J1ZmZlcixcbiAgdW5tYXNrOiBfdW5tYXNrXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbmlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnVubWFzayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFTVBUWV9CVUZGRVIiLCJyZXF1aXJlIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJsZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsImkiLCJidWYiLCJzZXQiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiX21hc2siLCJzb3VyY2UiLCJtYXNrIiwib3V0cHV0IiwiX3VubWFzayIsInRvQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic2xpY2UiLCJ0b0J1ZmZlciIsImRhdGEiLCJyZWFkT25seSIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmcm9tIiwibW9kdWxlIiwiZXhwb3J0cyIsInVubWFzayIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19CVUZGRVJfVVRJTCIsImJ1ZmZlclV0aWwiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\nif (hasBlob) BINARY_TYPES.push('blob');\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNQSxZQUFZLEdBQUcsQ0FBQyxZQUFZLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQztBQUMvRCxNQUFNQyxPQUFPLEdBQUcsT0FBT0MsSUFBSSxLQUFLLFdBQVc7QUFFM0MsSUFBSUQsT0FBTyxFQUFFRCxZQUFZLENBQUNHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFFdENDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZMLFlBQVk7RUFDWk0sWUFBWSxFQUFFQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0JDLElBQUksRUFBRSxzQ0FBc0M7RUFDNUNSLE9BQU87RUFDUFMsb0JBQW9CLEVBQUVDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQztFQUN0REMsU0FBUyxFQUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDO0VBQzlCRSxXQUFXLEVBQUVGLE1BQU0sQ0FBQyxhQUFhLENBQUM7RUFDbENHLFVBQVUsRUFBRUgsTUFBTSxDQUFDLFdBQVcsQ0FBQztFQUMvQkksSUFBSSxFQUFFQSxDQUFBLEtBQU0sQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz9jMmEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuY29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcbiAgaGFzQmxvYixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIE5PT1A6ICgpID0+IHt9XG59O1xuIl0sIm5hbWVzIjpbIkJJTkFSWV9UWVBFUyIsImhhc0Jsb2IiLCJCbG9iIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJFTVBUWV9CVUZGRVIiLCJCdWZmZXIiLCJhbGxvYyIsIkdVSUQiLCJrRm9yT25FdmVudEF0dHJpYnV0ZSIsIlN5bWJvbCIsImtMaXN0ZW5lciIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsIk5PT1AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBLG9CQUFvQjtFQUFFQztBQUFVLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyw2REFBYSxDQUFDO0FBRWxFLE1BQU1DLEtBQUssR0FBR0MsTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNQyxLQUFLLEdBQUdELE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDN0IsTUFBTUUsTUFBTSxHQUFHRixNQUFNLENBQUMsUUFBUSxDQUFDO0FBQy9CLE1BQU1HLFFBQVEsR0FBR0gsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUNuQyxNQUFNSSxPQUFPLEdBQUdKLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDakMsTUFBTUssT0FBTyxHQUFHTCxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ2pDLE1BQU1NLEtBQUssR0FBR04sTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNTyxTQUFTLEdBQUdQLE1BQU0sQ0FBQyxXQUFXLENBQUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE1BQU1RLEtBQUssQ0FBQztFQUNWO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFDQyxJQUFJLEVBQUU7SUFDaEIsSUFBSSxDQUFDTCxPQUFPLENBQUMsR0FBRyxJQUFJO0lBQ3BCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEdBQUdJLElBQUk7RUFDcEI7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsSUFBSUMsTUFBTUEsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJLENBQUNOLE9BQU8sQ0FBQztFQUN0Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxJQUFJSyxJQUFJQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDO0VBQ3BCO0FBQ0Y7QUFFQU0sTUFBTSxDQUFDQyxjQUFjLENBQUNMLEtBQUssQ0FBQ00sU0FBUyxFQUFFLFFBQVEsRUFBRTtFQUFF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QVEsQ0FBQztRQUNuQztNQUNGO0lBQ0Y7RUFDRjtBQUNGLENBQUM7QUFFRGlCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZoQyxVQUFVO0VBQ1ZNLFVBQVU7RUFDVmQsS0FBSztFQUNMbUIsV0FBVztFQUNYRjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNZLFlBQVlBLENBQUNQLFFBQVEsRUFBRW1CLE9BQU8sRUFBRWQsS0FBSyxFQUFFO0VBQzlDLElBQUksT0FBT0wsUUFBUSxLQUFLLFFBQVEsSUFBSUEsUUFBUSxDQUFDb0IsV0FBVyxFQUFFO0lBQ3hEcEIsUUFBUSxDQUFDb0IsV0FBVyxDQUFDQyxJQUFJLENBQUNyQixRQUFRLEVBQUVLLEtBQUssQ0FBQztFQUM1QyxDQUFDLE1BQU07SUFDTEwsUUFBUSxDQUFDcUIsSUFBSSxDQUFDRixPQUFPLEVBQUVkLEtBQUssQ0FBQztFQUMvQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/MzM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsInJlcXVpcmUiLCJrQ29kZSIsIlN5bWJvbCIsImtEYXRhIiwia0Vycm9yIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ0YXJnZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50Iiwib3B0aW9ucyIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJNZXNzYWdlRXZlbnQiLCJkYXRhIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwid3JhcHBlciIsIm9uTWVzc2FnZSIsImlzQmluYXJ5IiwiZXZlbnQiLCJ0b1N0cmluZyIsImNhbGxMaXN0ZW5lciIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25FcnJvciIsIm9uT3BlbiIsIm9uY2UiLCJvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0aGlzQXJnIiwiaGFuZGxlRXZlbnQiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions).map(extension => {\n    let configurations = extensions[extension];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\nmodule.exports = {\n  format,\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBO0FBQVcsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLCtEQUFjLENBQUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsSUFBSUEsQ0FBQ0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtFQUM5QixJQUFJRixJQUFJLENBQUNDLElBQUksQ0FBQyxLQUFLRSxTQUFTLEVBQUVILElBQUksQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsS0FDN0NGLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0UsS0FBS0EsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3JCLE1BQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2xDLElBQUlDLE1BQU0sR0FBR0YsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2hDLElBQUlFLFlBQVksR0FBRyxLQUFLO0VBQ3hCLElBQUlDLFVBQVUsR0FBRyxLQUFLO0VBQ3RCLElBQUlDLFFBQVEsR0FBRyxLQUFLO0VBQ3BCLElBQUlDLGFBQWE7RUFDakIsSUFBSUMsU0FBUztFQUNiLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0VBQ2IsSUFBSUMsR0FBRyxHQUFHLENBQUMsQ0FBQztFQUNaLElBQUlDLENBQUMsR0FBRyxDQUFDO0VBRVQsT0FBT0EsQ0FBQyxHQUFHYixNQUFNLENBQUNjLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7SUFDN0JGLElBQUksR0FBR1gsTUFBTSxDQUFDZSxV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RUFBRXRCO0FBQU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb3dzdGF0ZS1jYXRhbHlzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzP2EzMmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicHVzaCIsImRlc3QiLCJuYW1lIiwiZWxlbSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaGVhZGVyIiwib2ZmZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwicGFyYW1zIiwibXVzdFVuZXNjYXBlIiwiaXNFc2NhcGluZyIsImluUXVvdGVzIiwiZXh0ZW5zaW9uTmFtZSIsInBhcmFtTmFtZSIsInN0YXJ0IiwiY29kZSIsImVuZCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJzbGljZSIsInZhbHVlIiwicmVwbGFjZSIsInRva2VuIiwiZm9ybWF0IiwiZXh0ZW5zaW9ucyIsImtleXMiLCJtYXAiLCJleHRlbnNpb24iLCJjb25maWd1cmF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImsiLCJ2YWx1ZXMiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\nmodule.exports = Limiter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTUEsS0FBSyxHQUFHQyxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQzdCLE1BQU1DLElBQUksR0FBR0QsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSxPQUFPLENBQUM7RUFDWjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBQ0MsV0FBVyxFQUFFO0lBQ3ZCLElBQUksQ0FBQ0wsS0FBSyxDQUFDLEdBQUcsTUFBTTtNQUNsQixJQUFJLENBQUNNLE9BQU8sRUFBRTtNQUNkLElBQUksQ0FBQ0osSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNkLENBQUM7SUFDRCxJQUFJLENBQUNHLFdBQVcsR0FBR0EsV0FBVyxJQUFJRSxRQUFRO0lBQzFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7SUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBRyxDQUFDO0VBQ2xCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFRyxHQUFHQSxDQUFDQyxHQUFHLEVBQUU7SUFDUCxJQUFJLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDRCxHQUFHLENBQUM7SUFDbkIsSUFBSSxDQUFDUixJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ2Q7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLENBQUNBLElBQUksSUFBSTtJQUNQLElBQUksSUFBSSxDQUFDSSxPQUFPLEtBQUssSUFBSSxDQUFDRCxXQUFXLEVBQUU7SUFFdkMsSUFBSSxJQUFJLENBQUNHLElBQUksQ0FBQ0ksTUFBTSxFQUFFO01BQ3BCLE1BQU1GLEdBQUcsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0ssS0FBSyxDQUFDLENBQUM7TUFFN0IsSUFBSSxDQUFDUCxPQUFPLEVBQUU7TUFDZEksR0FBRyxDQUFDLElBQUksQ0FBQ1YsS0FBSyxDQUFDLENBQUM7SUFDbEI7RUFDRjtBQUNGO0FBRUFjLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWixPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzPzgwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIl0sIm5hbWVzIjpbImtEb25lIiwiU3ltYm9sIiwia1J1biIsIkxpbWl0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbmN1cnJlbmN5IiwicGVuZGluZyIsIkluZmluaXR5Iiwiam9icyIsImFkZCIsImpvYiIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/ws/lib/limiter.js\");\nconst {\n  kStatusCode\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(new Error('The deflate stream was closed while data was being processed'));\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw(_objectSpread(_objectSpread({}, this._options.zlibInflateOptions), {}, {\n        windowBits\n      }));\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw(_objectSpread(_objectSpread({}, this._options.zlibDeflateOptions), {}, {\n        windowBits\n      }));\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on('data', deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data);\n    });\n  }\n}\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxTQUFBQSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFlLGVBQUEsQ0FBQWhCLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYyx5QkFBQSxHQUFBZCxNQUFBLENBQUFlLGdCQUFBLENBQUFsQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWMseUJBQUEsQ0FBQWYsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZ0IsY0FBQSxDQUFBbkIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQU4sQ0FBQSxFQUFBRCxD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QUMsQ0FBQzFDLElBQUksQ0FBQ3NILEtBQUssQ0FBQztJQUMxQjtFQUNGO0VBRUEsSUFBSSxDQUFDM0UsTUFBTSxDQUFDLEdBQUcsSUFBSTRFLFVBQVUsQ0FBQywyQkFBMkIsQ0FBQztFQUMxRCxJQUFJLENBQUM1RSxNQUFNLENBQUMsQ0FBQzZFLElBQUksR0FBRyxtQ0FBbUM7RUFDdkQsSUFBSSxDQUFDN0UsTUFBTSxDQUFDLENBQUNWLFdBQVcsQ0FBQyxHQUFHLElBQUk7RUFDaEMsSUFBSSxDQUFDd0YsY0FBYyxDQUFDLE1BQU0sRUFBRWxCLGFBQWEsQ0FBQztFQUMxQyxJQUFJLENBQUNNLEtBQUssQ0FBQyxDQUFDO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU1AsY0FBY0EsQ0FBQ1YsR0FBRyxFQUFFO0VBQzNCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxDQUFDckQsa0JBQWtCLENBQUMsQ0FBQ2lCLFFBQVEsR0FBRyxJQUFJO0VBQ3hDb0MsR0FBRyxDQUFDM0QsV0FBVyxDQUFDLEdBQUcsSUFBSTtFQUN2QixJQUFJLENBQUNRLFNBQVMsQ0FBQyxDQUFDbUQsR0FBRyxDQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanM/YzE3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJ6bGliIiwicmVxdWlyZSIsImJ1ZmZlclV0aWwiLCJMaW1pdGVyIiwia1N0YXR1c0NvZGUiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwic3BlY2llcyIsIlRSQUlMRVIiLCJmcm9tIiwia1Blck1lc3NhZ2VEZWZsYXRlIiwia1RvdGFsTGVuZ3RoIiwia0NhbGxiYWNrIiwia0J1ZmZlcnMiLCJrRXJyb3IiLCJ6bGliTGltaXRlciIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaXNTZXJ2ZXIiLCJtYXhQYXlsb2FkIiwiX21heFBheWxvYWQiLCJfb3B0aW9ucyIsIl90aHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJfaXNTZXJ2ZXIiLCJfZGVmbGF0ZSIsIl9pbmZsYXRlIiwicGFyYW1zIiwiY29uY3VycmVuY3kiLCJjb25jdXJyZW5jeUxpbWl0IiwiZXh0ZW5zaW9uTmFtZSIsIm9mZmVyIiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciIsImNsaWVudE5vQ29udGV4dFRha2VvdmVyIiwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwic2VydmVyX21heF93aW5kb3dfYml0cyIsImNsaWVudE1heFdpbmRvd0JpdHMiLCJjbGllbnRfbWF4X3dpbmRvd19iaXRzIiwiYWNjZXB0IiwiY29uZmlndXJhdGlvbnMiLCJub3JtYWxpemVQYXJhbXMiLCJhY2NlcHRBc1NlcnZlciIsImFjY2VwdEFzQ2xpZW50IiwiY2xlYW51cCIsImNsb3NlIiwiY2FsbGJhY2siLCJFcnJvciIsIm9mZmVycyIsIm9wdHMiLCJhY2NlcHRlZCIsImZpbmQiLCJyZXNwb25zZSIsIm51bSIsImlzSW50ZWdlciIsImRlY29tcHJlc3MiLCJkYXRhIiwiZmluIiwiYWRkIiwiZG9uZSIsIl9kZWNvbXByZXNzIiwiZXJyIiwicmVzdWx0IiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJjb25jYXQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZXNldCIsImNyZWF0ZURlZmxhdGVSYXciLCJ6bGliRGVmbGF0ZU9wdGlvbnMiLCJkZWZsYXRlT25EYXRhIiwiWl9TWU5DX0ZMVVNIIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsIlJhbmdlRXJyb3IiLCJjb2RlIiwicmVtb3ZlTGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Writable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      cb(error);\n      return;\n    }\n    const compressed = (buf[0] & 0x40) === 0x40;\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      cb(error);\n      return;\n    }\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (!this._fragmented) {\n        const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n        cb(error);\n        return;\n      }\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      cb(error);\n      return;\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n      cb(error);\n      return;\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n      cb(error);\n      return;\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n        cb(error);\n        return;\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n          cb(error);\n          return;\n        }\n        this._fragments.push(buf);\n      }\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n    if (this._opcode === 2) {\n      let data;\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        cb(error);\n        return;\n      }\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n          cb(error);\n          return;\n        }\n        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n          cb(error);\n          return;\n        }\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n      this._state = GET_INFO;\n      return;\n    }\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\nmodule.exports = Receiver;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBUyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUV0QyxNQUFNQyxpQkFBaUIsR0FBR0QsbUJBQU8sQ0FBQywrRUFBc0IsQ0FBQztBQUN6RCxNQUFNO0VBQ0pFLFlBQVk7RUFDWkMsWUFBWTtFQUNaQyxXQUFXO0VBQ1hDO0FBQ0YsQ0FBQyxHQUFHTCxtQkFBTyxDQUFDLDZEQUFhLENBQUM7QUFDMUIsTUFBTTtFQUFFTSxNQUFNO0VBQUVDLGFBQWE7RUFBRUM7QUFBTyxDQUFDLEdBQUdSLG1CQUFPLENBQUMsaUVBQWUsQ0FBQztBQUNsRSxNQUFNO0VBQUVTLGlCQUFpQjtFQUFFQztBQUFZLENBQUMsR0FBR1YsbUJBQU8sQ0FBQywrREFBYyxDQUFDO0FBRWxFLE1BQU1XLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNDLE9BQU8sQ0FBQztBQUV6QyxNQUFNQyxRQUFRLEdBQUcsQ0FBQztBQUNsQixNQUFNQyxxQkFBcUIsR0FBRyxDQUFDO0FBQy9CLE1BQU1DLHFCQUFxQixHQUFHLENBQUM7QUFDL0IsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsU0FBUyxHQUFHLENBQUM7QUFDbkIsTUFBTUMsV0FBVyxHQUFHLENBQUM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxRQUFRLFNBQVN2QixRQUFRLENBQUM7RUFDOUI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXdCLFdBQVdBLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN4QixLQUFLLENBQUMsQ0FBQztJQUVQLElBQUksQ0FBQ0MsdUJBQXVCLEdBQzFCRCxP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LENBQUNDLE9BQU8sR0FBR3RGLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzPzA5NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIl0sIm5hbWVzIjpbIldyaXRhYmxlIiwicmVxdWlyZSIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiY29uY2F0IiwidG9BcnJheUJ1ZmZlciIsInVubWFzayIsImlzVmFsaWRTdGF0dXNDb2RlIiwiaXNWYWxpZFVURjgiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsIkdFVF9JTkZPIiwiR0VUX1BBWUxPQURfTEVOR1RIXzE2IiwiR0VUX1BBWUxPQURfTEVOR1RIXzY0IiwiR0VUX01BU0siLCJHRVRfREFUQSIsIklORkxBVElORyIsIkRFRkVSX0VWRU5UIiwiUmVjZWl2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJ1bmRlZmluZWQiLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlciIsIl9tYXhQYXlsb2FkIiwibWF4UGF5bG9hZCIsIl9za2lwVVRGOFZhbGlkYXRpb24iLCJza2lwVVRGOFZhbGlkYXRpb24iLCJfYnVmZmVyZWRCeXRlcyIsIl9idWZmZXJzIiwiX2NvbXByZXNzZWQiLCJfcGF5bG9hZExlbmd0aCIsIl9tYXNrIiwiX2ZyYWdtZW50ZWQiLCJfbWFza2VkIiwiX2ZpbiIsIl9vcGNvZGUiLCJfdG90YWxQYXlsb2FkTGVuZ3RoIiwiX21lc3NhZ2VMZW5ndGgiLCJfZnJhZ21lbnRzIiwiX2Vycm9yZWQiLCJfbG9vcCIsIl9zdGF0ZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImxlbmd0aCIsInB1c2giLCJzdGFydExvb3AiLCJjb25zdW1lIiwibiIsInNoaWZ0IiwiYnVmIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImRzdCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImVycm9yIiwiY3JlYXRlRXJyb3IiLCJSYW5nZUVycm9yIiwiY29tcHJlc3NlZCIsImV4dGVuc2lvbk5hbWUiLCJoYXZlTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwibnVtIiwicmVhZFVJbnQzMkJFIiwiTWF0aCIsInBvdyIsImRhdGEiLCJjb250cm9sTWVzc2FnZSIsImRlY29tcHJlc3MiLCJkYXRhTWVzc2FnZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXJyIiwibWVzc2FnZUxlbmd0aCIsImZyYWdtZW50cyIsIkJsb2IiLCJlbWl0Iiwic2V0SW1tZWRpYXRlIiwiRXJyb3IiLCJlbmQiLCJjb2RlIiwiRXJyb3JDdG9yIiwibWVzc2FnZSIsInByZWZpeCIsInN0YXR1c0NvZGUiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while the blob was being read\");\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === \"function\") cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxFQUFFbkIsR0FBRyxFQUFFM0IsRUFBRTtJQUM5QitCLGNBQWNlLFFBQVFuQixLQUFLM0I7SUFDM0I4QyxPQUFPcEUsT0FBTyxDQUFDaUQ7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcz82YjhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSLCBrV2ViU29ja2V0LCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBSQU5ET01fUE9PTF9TSVpFID0gOCAqIDEwMjQ7XG5sZXQgcmFuZG9tUG9vbDtcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XG5cbmNvbnN0IERFRkFVTFQgPSAwO1xuY29uc3QgREVGTEFUSU5HID0gMTtcbmNvbnN0IEdFVF9CTE9CX0RBVEEgPSAyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICB0aGlzLm9uZXJyb3IgPSBOT09QO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICBpZiAocmFuZG9tUG9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcbiAgICAgICAgICAgIC8vIGJlIG1hc2tlZCBzbyBpdCBtYXkgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIHJhbmRvbVBvb2xQb2ludGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcblxuICAgIGJsb2JcbiAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayB0byBlbnN1cmUgdGhhdCBlcnJvcnNcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYG9uRXJyb3JgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIGZvciB0aGUgc2FtZSByZWFzb24gdGhhdFxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG4gICAgICAgIC8vXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sob25FcnJvciwgdGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBERUZMQVRJTkc7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuXG4vKipcbiAqIENhbGxzIHF1ZXVlZCBjYWxsYmFja3Mgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZW5kZXIuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLl9xdWV1ZVtpXTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhIGBTZW5kZXJgIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBwZW5kaW5nIGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvbkVycm9yKHNlbmRlciwgZXJyLCBjYikge1xuICBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYik7XG4gIHNlbmRlci5vbmVycm9yKGVycik7XG59XG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsInJhbmRvbUZpbGxTeW5jIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFTVBUWV9CVUZGRVIiLCJrV2ViU29ja2V0IiwiTk9PUCIsImlzQmxvYiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJSQU5ET01fUE9PTF9TSVpFIiwicmFuZG9tUG9vbCIsInJhbmRvbVBvb2xQb2ludGVyIiwiREVGQVVMVCIsIkRFRkxBVElORyIsIkdFVF9CTE9CX0RBVEEiLCJTZW5kZXIiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJnZW5lcmF0ZU1hc2siLCJfZXh0ZW5zaW9ucyIsIl9nZW5lcmF0ZU1hc2siLCJfbWFza0J1ZmZlciIsIl9zb2NrZXQiLCJfZmlyc3RGcmFnbWVudCIsIl9jb21wcmVzcyIsIl9idWZmZXJlZEJ5dGVzIiwiX3F1ZXVlIiwiX3N0YXRlIiwib25lcnJvciIsInVuZGVmaW5lZCIsImZyYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJtZXJnZSIsIm9mZnNldCIsInNraXBNYXNraW5nIiwiZGF0YUxlbmd0aCIsImZyb20iLCJsZW5ndGgiLCJyZWFkT25seSIsInBheWxvYWRMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsIlR5cGVFcnJvciIsImJ5dGVMZW5ndGgiLCJSYW5nZUVycm9yIiwid3JpdGUiLCJzZXQiLCJlbnF1ZXVlIiwiZGlzcGF0Y2giLCJzZW5kRnJhbWUiLCJwaW5nIiwic2l6ZSIsImdldEJsb2JEYXRhIiwicG9uZyIsInNlbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImV4dGVuc2lvbk5hbWUiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBhcmFtcyIsIl9pc1NlcnZlciIsIl90aHJlc2hvbGQiLCJvcHRzIiwiYmxvYiIsImFycmF5QnVmZmVyIiwidGhlbiIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbENhbGxiYWNrcyIsImRlcXVldWUiLCJjYXRjaCIsIm9uRXJyb3IiLCJfIiwic2hpZnQiLCJSZWZsZWN0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwiY29yayIsInVuY29yayIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZW5kZXIiLCJpIiwiY2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex(_objectSpread(_objectSpread({}, options), {}, {\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  }));\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\nmodule.exports = createWebSocketStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ29CLFVBQVUsS0FBS3BCLEVBQUUsQ0FBQzJCLFVBQVUsRUFBRTtNQUNuQzNCLEVBQUUsQ0FBQ2UsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTYSxJQUFJQSxDQUFBLEVBQUc7UUFDOUJ6QixNQUFNLENBQUNnQyxNQUFNLENBQUNDLEtBQUssRUFBRUMsUUFBUSxFQUFFbEIsUUFBUSxDQUFDO01BQzFDLENBQUMsQ0FBQztNQUNGO0lBQ0Y7SUFFQW5CLEVBQUUsQ0FBQ3NDLElBQUksQ0FBQ0YsS0FBSyxFQUFFakIsUUFBUSxDQUFDO0VBQzFCLENBQUM7RUFFRGhCLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEtBQUssRUFBRWpCLFdBQVcsQ0FBQztFQUM3QmEsTUFBTSxDQUFDSSxFQUFFLENBQUMsT0FBTyxFQUFFWixhQUFhLENBQUM7RUFDakMsT0FBT1EsTUFBTTtBQUNmO0FBRUFvQyxNQUFNLENBQUNDLE9BQU8sR0FBR3pDLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb3dzdGF0ZS1jYXRhbHlzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzP2NhOTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiRHVwbGV4IiwicmVxdWlyZSIsImVtaXRDbG9zZSIsInN0cmVhbSIsImVtaXQiLCJkdXBsZXhPbkVuZCIsImRlc3Ryb3llZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJkZXN0cm95IiwiZHVwbGV4T25FcnJvciIsImVyciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIndzIiwib3B0aW9ucyIsInRlcm1pbmF0ZU9uRGVzdHJveSIsImR1cGxleCIsImF1dG9EZXN0cm95Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm9uIiwibWVzc2FnZSIsIm1zZyIsImlzQmluYXJ5IiwiZGF0YSIsIl9yZWFkYWJsZVN0YXRlIiwidG9TdHJpbmciLCJwYXVzZSIsIm9uY2UiLCJlcnJvciIsImNsb3NlIiwiX2Rlc3Ryb3kiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsZWQiLCJ0ZXJtaW5hdGUiLCJfZmluYWwiLCJDT05ORUNUSU5HIiwib3BlbiIsIl9zb2NrZXQiLCJlbmRFbWl0dGVkIiwiZmluaXNoIiwiX3JlYWQiLCJpc1BhdXNlZCIsInJlc3VtZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJzZW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1) end = i;\n      const protocol = header.slice(start, end);\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nmodule.exports = {\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBVyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsK0RBQWMsQ0FBQzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxLQUFLQSxDQUFDQyxNQUFNLEVBQUU7RUFDckIsTUFBTUMsU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQzNCLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0VBQ1osSUFBSUMsQ0FBQyxHQUFHLENBQUM7RUFFVCxLQUFLQSxDQUFDLEVBQUVBLENBQUMsR0FBR0wsTUFBTSxDQUFDTSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQzlCLE1BQU1FLElBQUksR0FBR1AsTUFBTSxDQUFDUSxVQUFVLENBQUNILENBQUMsQ0FBQztJQUVqQyxJQUFJRCxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUlQLFVBQVUsQ0FBQ1UsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO01BQ3hDLElBQUlKLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRUEsS0FBSyxHQUFHRSxDQUFDO0lBQzdCLENBQUMsTUFBTSxJQUNMQSxDQUFDLEtBQUssQ0FBQyxLQUNORSxJQUFJLEtBQUssSUFBSSxDQUFDLGFBQWFBLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxZQUMzQztNQUNBLElBQUlILEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSUQsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFQyxHQUFHLEdBQUdDLENBQUM7SUFDekMsQ0FBQyxNQUFNLElBQUlFLElBQUksS0FBSyxJQUFJLENBQUMsV0FBVztNQUNsQyxJQUFJSixLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDaEIsTUFBTSxJQUFJTSxXQUFXLENBQUUsaUNBQWdDSixDQUFFLEVBQUMsQ0FBQztNQUM3RDtNQUVBLElBQUlELEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRUEsR0FBRyxHQUFHQyxDQUFDO01BRXZCLE1BQU1LLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUMsR0FBRyxDQUFDO01BRXpDLElBQUlILFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtRQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO01BQ3RFO01BRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7TUFDdkJQLEtBQUssR0FBR0MsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNsQixDQUFDLE1BQU07TUFDTCxNQUFNLElBQUlLLFdBQVcsQ0FBRSxpQ0FBZ0NKLENBQUUsRUFBQyxDQUFDO0lBQzdEO0VBQ0Y7RUFFQSxJQUFJRixLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUlDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUM5QixNQUFNLElBQUlLLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQztFQUNsRDtFQUVBLE1BQU1DLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUUsQ0FBQyxDQUFDO0VBRXZDLElBQUlKLFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtJQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO0VBQ3RFO0VBRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7RUFDdkIsT0FBT1QsU0FBUztBQUNsQjtBQUVBYSxNQUFNLENBQUNDLE9BQU8sR0FBRztFQUFFaEI7QUFBTSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvd3N0YXRlLWNhdGFseXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcz9hZWIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpICE9PSAwICYmXG4gICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcblxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICB9XG5cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicGFyc2UiLCJoZWFkZXIiLCJwcm90b2NvbHMiLCJTZXQiLCJzdGFydCIsImVuZCIsImkiLCJsZW5ndGgiLCJjb2RlIiwiY2hhckNvZGVBdCIsIlN5bnRheEVycm9yIiwicHJvdG9jb2wiLCJzbGljZSIsImhhcyIsImFkZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  isUtf8\n} = __webpack_require__(/*! buffer */ \"buffer\");\nconst {\n  hasBlob\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n// 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return hasBlob && typeof value === 'object' && typeof value.arrayBuffer === 'function' && typeof value.type === 'string' && typeof value.stream === 'function' && (value[Symbol.toStringTag] === 'Blob' || value[Symbol.toStringTag] === 'File');\n}\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTTtFQUFFQTtBQUFPLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyxzQkFBUSxDQUFDO0FBRXBDLE1BQU07RUFBRUM7QUFBUSxDQUFDLEdBQUdELG1CQUFPLENBQUMsNkRBQWEsQ0FBQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsVUFBVSxHQUFHLENBQ2pCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBQSxDQUNoRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLGlCQUFpQkEsQ0FBQ0MsSUFBSSxFQUFFO0VBQy9CLE9BQ0dBLElBQUksSUFBSSxJQUFJLElBQ1hBLElBQUksSUFBSSxJQUFJLElBQ1pBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2RB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dmFsaWRhdGlvbi5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaGFzQmxvYiAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxuICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCbG9iLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc1V0ZjgiLCJyZXF1aXJlIiwiaGFzQmxvYiIsInRva2VuQ2hhcnMiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImNvZGUiLCJfaXNWYWxpZFVURjgiLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJpIiwiaXNCbG9iIiwidmFsdWUiLCJhcnJheUJ1ZmZlciIsInR5cGUiLCJzdHJlYW0iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1ZhbGlkVVRGOCIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19VVEZfOF9WQUxJREFURSIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\nconst {\n  GUID,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = _objectSpread({\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket\n    }, options);\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once('close', cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = _objectSpread({\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message)\n  }, headers);\n  socket.once('finish', socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBQUEsU0FBQUEsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBLFFBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxJQUFBLENBQUFKLENBQUEsT0FBQUcsTUFBQSxDQUFBRSxxQkFBQSxRQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQUwsQ0FBQSxHQUFBQyxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFOLENBQUEsV0FBQUUsTUFBQSxDQUFBSyx3QkFBQSxDQUFBUixDQUFBLEVBQUFDLENBQUEsRUFBQVEsVUFBQSxPQUFBUCxDQUFBLENBQUFRLElBQUEsQ0FBQUMsS0FBQSxDQUFBVCxDQUFBLEVBQUFJLENBQUEsWUFBQUosQ0FBQTtBQUFBLFNBQUFVLGNBQUFaLENBQUEsYUFBQUMsQ0FBQSxNQUFBQSxDQUFBLEdBQUFZLFNBQUEsQ0FBQUMsTUFBQSxFQUFBYixDQUFBLFVBQUFDLENBQUEsV0FBQVcsU0FBQSxDQUFBWixDQUFBLElBQUFZLFNBQUEsQ0FBQVosQ0FBQSxRQUFBQSxDQUFBLE9BQUFGLE9BQUEsQ0FBQUksTUFBQSxDQUFBRCxDQUFBLE9BQUFhLE9BQUEsV0FBQWQsQ0FBQSxJQUFBZSxlQUFBLENBQUFoQixDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxDQUFBRCxDQUFBLFNBQUFFLE1BQUEsQ0FBQWMseUJBQUEsR0FBQWQsTUFBQSxDQUFBZSxnQkFBQSxDQUFBbEIsQ0FBQSxFQUFBRyxNQUFBLENBQUFjLHlCQUFBLENBQUFmLENBQUEsS0FBQUgsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsR0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFFLE1BQUEsQ0FBQWdCLGNBQUEsQ0FBQW5CLENBQUEsRUFBQUMsQ0FBQSxFQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFOLENBQUEsRUFB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RCxPQUFPLENBQUM7RUFFckNsRCxNQUFNLENBQUNWLEdBQUcsQ0FDUCxZQUFXeUQsSUFBSyxJQUFHOUYsSUFBSSxDQUFDbUMsWUFBWSxDQUFDMkQsSUFBSSxDQUFFLE1BQUssR0FDL0NwSSxNQUFNLENBQUNDLElBQUksQ0FBQzRHLE9BQU8sQ0FBQyxDQUNqQjhDLEdBQUcsQ0FBRU0sQ0FBQyxJQUFNLEdBQUVBLENBQUUsS0FBSXBELE9BQU8sQ0FBQ29ELENBQUMsQ0FBRSxFQUFDLENBQUMsQ0FDakNiLElBQUksQ0FBQyxNQUFNLENBQUMsR0FDZixVQUFVLEdBQ1ZwQyxPQUNKLENBQUM7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsaUNBQWlDQSxDQUFDaEQsTUFBTSxFQUFFTSxHQUFHLEVBQUVjLE1BQU0sRUFBRStDLElBQUksRUFBRXBCLE9BQU8sRUFBRTtFQUM3RSxJQUFJL0MsTUFBTSxDQUFDaUcsYUFBYSxDQUFDLGVBQWUsQ0FBQyxFQUFFO0lBQ3pDLE1BQU0xQyxHQUFHLEdBQUcsSUFBSTNCLEtBQUssQ0FBQ21CLE9BQU8sQ0FBQztJQUM5Qm5CLEtBQUssQ0FBQ3NFLGlCQUFpQixDQUFDM0MsR0FBRyxFQUFFUCxpQ0FBaUMsQ0FBQztJQUUvRGhELE1BQU0sQ0FBQ2EsSUFBSSxDQUFDLGVBQWUsRUFBRTBDLEdBQUcsRUFBRW5DLE1BQU0sRUFBRWQsR0FBRyxDQUFDO0VBQ2hELENBQUMsTUFBTTtJQUNMNkMsY0FBYyxDQUFDL0IsTUFBTSxFQUFFK0MsSUFBSSxFQUFFcEIsT0FBTyxDQUFDO0VBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanM/MDEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cCIsIkR1cGxleCIsImNyZWF0ZUhhc2giLCJleHRlbnNpb24iLCJQZXJNZXNzYWdlRGVmbGF0ZSIsInN1YnByb3RvY29sIiwiV2ViU29ja2V0IiwiR1VJRCIsImtXZWJTb2NrZXQiLCJrZXlSZWdleCIsIlJVTk5JTkciLCJDTE9TSU5HIiwiQ0xPU0VEIiwiV2ViU29ja2V0U2VydmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhbGxvd1N5bmNocm9ub3VzRXZlbnRzIiwiYXV0b1BvbmciLCJtYXhQYXlsb2FkIiwic2tpcFVURjhWYWxpZGF0aW9uIiwicGVyTWVzc2FnZURlZmxhdGUiLCJoYW5kbGVQcm90b2NvbHMiLCJjbGllbnRUcmFja2luZyIsInZlcmlmeUNsaWVudCIsIm5vU2VydmVyIiwiYmFja2xvZyIsInNlcnZlciIsImhvc3QiLCJwYXRoIiwicG9ydCIsIl9zZXJ2ZXIiLCJjcmVhdGVTZXJ2ZXIiLCJyZXEiLCJib2R5IiwiU1RBVFVTX0NPREVTIiwid3JpdGVIZWFkIiwiZW5kIiwibGlzdGVuIiwiZW1pdENvbm5lY3Rpb24iLCJlbWl0IiwiYmluZCIsIl9yZW1vdmVMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lcnMiLCJsaXN0ZW5pbmciLCJlcnJvciIsInVwZ3JhZGUiLCJzb2NrZXQiLCJoZWFkIiwiaGFuZGxlVXBncmFkZSIsImNsaWVudHMiLCJTZXQiLCJfc2hvdWxkRW1pdENsb3NlIiwiX3N0YXRlIiwiYWRkcmVzcyIsIkVycm9yIiwiY2xvc2UiLCJjYiIsIm9uY2UiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0Q2xvc2UiLCJzaXplIiwic2hvdWxkSGFuZGxlIiwiaW5kZXgiLCJ1cmwiLCJpbmRleE9mIiwicGF0aG5hbWUiLCJzbGljZSIsIm9uIiwic29ja2V0T25FcnJvciIsImhlYWRlcnMiLCJ2ZXJzaW9uIiwibWV0aG9kIiwibWVzc2FnZSIsImFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvciIsInRvTG93ZXJDYXNlIiwidGVzdCIsImFib3J0SGFuZHNoYWtlIiwic2VjV2ViU29ja2V0UHJvdG9jb2wiLCJwcm90b2NvbHMiLCJwYXJzZSIsImVyciIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwib2ZmZXJzIiwiZXh0ZW5zaW9uTmFtZSIsImFjY2VwdCIsImluZm8iLCJvcmlnaW4iLCJzZWN1cmUiLCJhdXRob3JpemVkIiwiZW5jcnlwdGVkIiwidmVyaWZpZWQiLCJjb2RlIiwiY29tcGxldGVVcGdyYWRlIiwicmVhZGFibGUiLCJkZXN0cm95IiwiZGlnZXN0IiwidXBkYXRlIiwid3MiLCJwcm90b2NvbCIsInZhbHVlcyIsIm5leHQiLCJfcHJvdG9jb2wiLCJwYXJhbXMiLCJmb3JtYXQiLCJfZXh0ZW5zaW9ucyIsIndyaXRlIiwiY29uY2F0Iiwiam9pbiIsInJlbW92ZUxpc3RlbmVyIiwic2V0U29ja2V0IiwiYWRkIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1hcCIsImV2ZW50IiwicmVtb3ZlTGlzdGVuZXJzIiwiQ29ubmVjdGlvbiIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJoIiwibGlzdGVuZXJDb3VudCIsImNhcHR1cmVTdGFja1RyYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst {\n  randomBytes,\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst {\n  Duplex,\n  Readable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  URL\n} = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/ws/lib/sender.js\");\nconst {\n  isBlob\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/ws/lib/event-target.js\");\nconst {\n  format,\n  parse\n} = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\nconst {\n  toBuffer\n} = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = _objectSpread({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = _objectSpread(_objectSpread({\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10\n  }, options), {}, {\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n  websocket._autoPong = opts.autoPong;\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n  websocket._url = parsedUrl.href;\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = _objectSpread(_objectSpread({}, opts.headers), {}, {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  });\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        headers: {}\n      });\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n    req = websocket._req = request(opts);\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n  req.on('error', err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const upgrade = res.headers.upgrade;\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n  websocket._receiver.end();\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFBQSxTQUFBQSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFlLGVBQUEsQ0FBQWhCLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYyx5QkFBQSxHQUFBZCxNQUFBLENBQUFlLGdCQUFBLENBQUFsQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWMseUJBQUEsQ0FBQWYsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZ0IsY0FBQSxDQUFBbkIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQU4sQ0FBQSxFQUFBRCxDQUFB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b2NrZXQuanM/M2Q5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXh8UmVhZGFibGUkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBEdXBsZXgsIFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3QgeyBpc0Jsb2IgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlELFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZSxcbiAga0xpc3RlbmVyLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldCxcbiAgTk9PUFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7XG4gIEV2ZW50VGFyZ2V0OiB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfVxufSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCB7IHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbmNvbnN0IGtBYm9ydGVkID0gU3ltYm9sKCdrQWJvcnRlZCcpO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSBFTVBUWV9CVUZGRVI7XG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb3RvY29sID0gJyc7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG5cbiAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwO1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZGlyZWN0cyA9IDA7XG5cbiAgICAgIGlmIChwcm90b2NvbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b1BvbmcgPSBvcHRpb25zLmF1dG9Qb25nO1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG5cbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc2VuZGVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XG5cbiAgICAvL1xuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxuICAgIC8vXG4gICAgaWYgKHNvY2tldC5zZXRUaW1lb3V0KSBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldENsb3NlVGltZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnaXNQYXVzZWQnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0KGhhbmRsZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBhbnlcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXG4gKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICogICAgIGN1c3RvbWl6ZSB0aGUgaGVhZGVycyBvZiBlYWNoIGh0dHAgcmVxdWVzdCBiZWZvcmUgaXQgaXMgc2VudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG4gICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxuICAgIGhvc3RuYW1lOiB1bmRlZmluZWQsXG4gICAgcHJvdG9jb2w6IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIHdlYnNvY2tldC5fYXV0b1BvbmcgPSBvcHRzLmF1dG9Qb25nO1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzOic7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3c3M6JztcbiAgfVxuXG4gIHdlYnNvY2tldC5fdXJsID0gcGFyc2VkVXJsLmhyZWY7XG5cbiAgY29uc3QgaXNTZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3c3M6JztcbiAgY29uc3QgaXNJcGNVcmwgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG4gIGxldCBpbnZhbGlkVXJsTWVzc2FnZTtcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzSXBjVXJsKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPVxuICAgICAgJ1RoZSBVUkxcXCdzIHByb3RvY29sIG11c3QgYmUgb25lIG9mIFwid3M6XCIsIFwid3NzOlwiLCAnICtcbiAgICAgICdcImh0dHA6XCIsIFwiaHR0cHNcIiwgb3IgXCJ3cyt1bml4OlwiJztcbiAgfSBlbHNlIGlmIChpc0lwY1VybCAmJiAhcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSAnVGhlIFVSTCBjb250YWlucyBhIGZyYWdtZW50IGlkZW50aWZpZXInO1xuICB9XG5cbiAgaWYgKGludmFsaWRVcmxNZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCByZXF1ZXN0ID0gaXNTZWN1cmUgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuICBjb25zdCBwcm90b2NvbFNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9XG4gICAgb3B0cy5jcmVhdGVDb25uZWN0aW9uIHx8IChpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0KTtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAuLi5vcHRzLmhlYWRlcnMsXG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCdcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8XG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xuICAgIH1cblxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNJcGNVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBsZXQgcmVxO1xuXG4gIGlmIChvcHRzLmZvbGxvd1JlZGlyZWN0cykge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbElwYyA9IGlzSXBjVXJsO1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSA9IGlzU2VjdXJlO1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGggPSBpc0lwY1VybFxuICAgICAgICA/IG9wdHMuc29ja2V0UGF0aFxuICAgICAgICA6IHBhcnNlZFVybC5ob3N0O1xuXG4gICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnM7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHVzZXIgcHJvdmlkZWQgb3B0aW9ucyBzbyB0aGF0IGhlYWRlcnMgY2FuIGJlIGNoYW5nZWRcbiAgICAgIC8vIHdpdGhvdXQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgIC8vXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7fSB9O1xuXG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2Vic29ja2V0Lmxpc3RlbmVyQ291bnQoJ3JlZGlyZWN0JykgPT09IDApIHtcbiAgICAgIGNvbnN0IGlzU2FtZUhvc3QgPSBpc0lwY1VybFxuICAgICAgICA/IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IG9wdHMuc29ja2V0UGF0aCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGhcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIDogd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcblxuICAgICAgaWYgKCFpc1NhbWVIb3N0IHx8ICh3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlICYmICFpc1NlY3VyZSkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIGRyb3AgdGhlIGZvbGxvd2luZyBoZWFkZXJzLiBUaGVzZVxuICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cbiAgICAgICAgLy9cbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcblxuICAgICAgICBpZiAoIWlzU2FtZUhvc3QpIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcblxuICAgICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgbWFrZSB0aGUgZmlyc3QgYEF1dGhvcml6YXRpb25gIGhlYWRlciB3aW4uXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcbiAgICAvLyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9XG4gICAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzKSB7XG4gICAgICAvL1xuICAgICAgLy8gVW5saWtlIHdoYXQgaXMgZG9uZSBmb3IgdGhlIGAndXBncmFkZSdgIGV2ZW50LCBubyBlYXJseSBleGl0IGlzXG4gICAgICAvLyB0cmlnZ2VyZWQgaGVyZSBpZiB0aGUgdXNlciBjYWxscyBgd2Vic29ja2V0LmNsb3NlKClgIG9yXG4gICAgICAvLyBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGAncmVkaXJlY3QnYCBldmVudC4gVGhpc1xuICAgICAgLy8gaXMgYmVjYXVzZSB0aGUgdXNlciBjYW4gYWxzbyBjYWxsIGByZXF1ZXN0LmRlc3Ryb3koKWAgd2l0aCBhbiBlcnJvclxuICAgICAgLy8gYmVmb3JlIGNhbGxpbmcgYHdlYnNvY2tldC5jbG9zZSgpYCBvciBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBhbmQgdGhpc1xuICAgICAgLy8gd291bGQgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIGVtaXR0ZWQgb24gdGhlIGByZXF1ZXN0YCBvYmplY3Qgd2l0aCBub1xuICAgICAgLy8gYCdlcnJvcidgIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZC5cbiAgICAgIC8vXG4gICAgICB3ZWJzb2NrZXQuZW1pdCgncmVkaXJlY3QnLCB3ZWJzb2NrZXQudXJsLCByZXEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG4gIH1cblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxW2tBYm9ydGVkXSkgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgIGlmIChcbiAgICAgIGxvY2F0aW9uICYmXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgIHN0YXR1c0NvZGUgPCA0MDBcbiAgICApIHtcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICBsZXQgYWRkcjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2xvY2F0aW9ufWApO1xuICAgICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2UoXG4gICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgcmVxLFxuICAgICAgICBgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2U6ICR7cmVzLnN0YXR1c0NvZGV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHdlYnNvY2tldC5lbWl0KCd1cGdyYWRlJywgcmVzKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIHVzZXIgbWF5IGhhdmUgY2xvc2VkIHRoZSBjb25uZWN0aW9uIGZyb20gYSBsaXN0ZW5lciBvZiB0aGVcbiAgICAvLyBgJ3VwZ3JhZGUnYCBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXMuaGVhZGVycy51cGdyYWRlO1xuXG4gICAgaWYgKHVwZ3JhZGUgPT09IHVuZGVmaW5lZCB8fCB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBkaWdlc3QpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdEVycm9yO1xuXG4gICAgaWYgKHNlcnZlclByb3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBubyBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5fcHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgJ1NlcnZlciBzZW50IGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBidXQgbm8gZXh0ZW5zaW9uICcgK1xuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnNpb25zO1xuXG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcblxuICAgICAgaWYgKFxuICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRzLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBnZW5lcmF0ZU1hc2s6IG9wdHMuZ2VuZXJhdGVNYXNrLFxuICAgICAgbWF4UGF5bG9hZDogb3B0cy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuICB9KTtcblxuICBpZiAob3B0cy5maW5pc2hSZXF1ZXN0KSB7XG4gICAgb3B0cy5maW5pc2hSZXF1ZXN0KHJlcSwgd2Vic29ja2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXEuZW5kKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbWl0IHRoZSBgJ2Vycm9yJ2AgYW5kIGAnY2xvc2UnYCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXNzaWdubWVudCBpcyBwcmFjdGljYWxseSB1c2VsZXNzIGFuZCBpcyBkb25lIG9ubHkgZm9yXG4gIC8vIGNvbnNpc3RlbmN5LlxuICAvL1xuICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbVtrQWJvcnRlZF0gPSB0cnVlO1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuXG4gICAgaWYgKHN0cmVhbS5zb2NrZXQgJiYgIXN0cmVhbS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAvL1xuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgY29tcGxldGVkLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxuICAgICAgLy9cbiAgICAgIHN0cmVhbS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2UsIHdlYnNvY2tldCwgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gaXNCbG9iKGRhdGEpID8gZGF0YS5zaXplIDogdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAoIXdlYnNvY2tldC5pc1BhdXNlZCkgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgICAvL1xuICAgIC8vIE9uIE5vZGUuanMgPCAxNC4wLjAgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIHN5bmNocm9ub3VzbHkuIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxuICAgIC8vXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcbiAgfVxuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSBUaGUgcmVhZGFibGUgc3RyZWFtXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtKSB7XG4gIHN0cmVhbS5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgYFNlbmRlcmAgZXJyb3IgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCk7XG4gIH1cblxuICAvL1xuICAvLyBgc29ja2V0LmVuZCgpYCBpcyB1c2VkIGluc3RlYWQgb2YgYHNvY2tldC5kZXN0cm95KClgIHRvIGFsbG93IHRoZSBvdGhlclxuICAvLyBwZWVyIHRvIGZpbmlzaCBzZW5kaW5nIHF1ZXVlZCBkYXRhLiBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCBhIHRpbWVyIGhlcmVcbiAgLy8gYmVjYXVzZSBgQ0xPU0lOR2AgbWVhbnMgdGhhdCBpdCBpcyBhbHJlYWR5IHNldCBvciBub3QgbmVlZGVkLlxuICAvL1xuICB0aGlzLl9zb2NrZXQuZW5kKCk7XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgdGltZXIgdG8gZGVzdHJveSB0aGUgdW5kZXJseWluZyByYXcgc29ja2V0IG9mIGEgV2ViU29ja2V0LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpIHtcbiAgd2Vic29ja2V0Ll9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95LmJpbmQod2Vic29ja2V0Ll9zb2NrZXQpLFxuICAgIGNsb3NlVGltZW91dFxuICApO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgbGV0IGNodW5rO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cbiAgLy9cbiAgaWYgKFxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXG4gICkge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG5cbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcblxuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzLmVuZCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cbiAgaWYgKHdlYnNvY2tldCkge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iXSwibmFtZXMiOlsib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cHMiLCJodHRwIiwibmV0IiwidGxzIiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVIYXNoIiwiRHVwbGV4IiwiUmVhZGFibGUiLCJVUkwiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiaXNCbG9iIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmb3JtYXQiLCJwYXJzZSIsInRvQnVmZmVyIiwiY2xvc2VUaW1lb3V0Iiwia0Fib3J0ZWQiLCJwcm90b2NvbFZlcnNpb25zIiwicmVhZHlTdGF0ZXMiLCJzdWJwcm90b2NvbFJlZ2V4IiwiV2ViU29ja2V0IiwiY29uc3RydWN0b3IiLCJhZGRyZXNzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIl9iaW5hcnlUeXBlIiwiX2Nsb3NlQ29kZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfZXJyb3JFbWl0dGVkIiwiX2V4dGVuc2lvbnMiLCJfcGF1c2VkIiwiX3Byb3RvY29sIiwiX3JlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiX3JlY2VpdmVyIiwiX3NlbmRlciIsIl9zb2NrZXQiLCJfYnVmZmVyZWRBbW91bnQiLCJfaXNTZXJ2ZXIiLCJfcmVkaXJlY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5pdEFzQ2xpZW50IiwiX2F1dG9Qb25nIiwiYXV0b1BvbmciLCJiaW5hcnlUeXBlIiwidHlwZSIsImluY2x1ZGVzIiwiYnVmZmVyZWRBbW91bnQiLCJfd3JpdGFibGVTdGF0ZSIsIl9idWZmZXJlZEJ5dGVzIiwiZXh0ZW5zaW9ucyIsImpvaW4iLCJpc1BhdXNlZCIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJyZWNlaXZlciIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJzZW5kZXIiLCJnZW5lcmF0ZU1hc2siLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNlbmRlck9uRXJyb3IiLCJzZXRUaW1lb3V0Iiwic2V0Tm9EZWxheSIsInVuc2hpZnQiLCJzb2NrZXRPbkNsb3NlIiwic29ja2V0T25EYXRhIiwic29ja2V0T25FbmQiLCJzb2NrZXRPbkVycm9yIiwiT1BFTiIsImVtaXQiLCJlbWl0Q2xvc2UiLCJDTE9TRUQiLCJleHRlbnNpb25OYW1lIiwiY2xlYW51cCIsInJlbW92ZUFsbExpc3RlbmVycyIsImNsb3NlIiwiY29kZSIsImRhdGEiLCJtc2ciLCJhYm9ydEhhbmRzaGFrZSIsIl9yZXEiLCJDTE9TSU5HIiwiZXJyb3JFbWl0dGVkIiwiZW5kIiwiZXJyIiwic2V0Q2xvc2VUaW1lciIsInBhdXNlIiwicGluZyIsIm1hc2siLCJjYiIsIkVycm9yIiwidG9TdHJpbmciLCJzZW5kQWZ0ZXJDbG9zZSIsInBvbmciLCJyZXN1bWUiLCJuZWVkRHJhaW4iLCJzZW5kIiwib3B0cyIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZGVzdHJveSIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwic2V0IiwiaGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIndlYnNvY2tldCIsInByb3RvY29sVmVyc2lvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZm9sbG93UmVkaXJlY3RzIiwibWF4UmVkaXJlY3RzIiwic29ja2V0UGF0aCIsImhvc3RuYW1lIiwidGltZW91dCIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlJhbmdlRXJyb3IiLCJwYXJzZWRVcmwiLCJTeW50YXhFcnJvciIsImhyZWYiLCJpc1NlY3VyZSIsImlzSXBjVXJsIiwiaW52YWxpZFVybE1lc3NhZ2UiLCJwYXRobmFtZSIsImhhc2giLCJlbWl0RXJyb3JBbmRDbG9zZSIsImRlZmF1bHRQb3J0IiwicmVxdWVzdCIsInByb3RvY29sU2V0IiwiU2V0IiwiY3JlYXRlQ29ubmVjdGlvbiIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiaGVhZGVycyIsIkNvbm5lY3Rpb24iLCJVcGdyYWRlIiwic2VhcmNoIiwiaGFuZHNoYWtlVGltZW91dCIsIm9mZmVyIiwidGVzdCIsImhhcyIsImFkZCIsIm9yaWdpbiIsIk9yaWdpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwicGFydHMiLCJzcGxpdCIsInJlcSIsIl9vcmlnaW5hbElwYyIsIl9vcmlnaW5hbFNlY3VyZSIsIl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGgiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJsaXN0ZW5lckNvdW50IiwiaXNTYW1lSG9zdCIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJCdWZmZXIiLCJmcm9tIiwibG9jYXRpb24iLCJzdGF0dXNDb2RlIiwiYWJvcnQiLCJhZGRyIiwidXBncmFkZSIsImRpZ2VzdCIsInVwZGF0ZSIsInNlcnZlclByb3QiLCJwcm90RXJyb3IiLCJzaXplIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsIm1lc3NhZ2UiLCJleHRlbnNpb25OYW1lcyIsImFjY2VwdCIsImZpbmlzaFJlcXVlc3QiLCJjb25uZWN0Iiwic2VydmVybmFtZSIsImlzSVAiLCJzdHJlYW0iLCJjYXB0dXJlU3RhY2tUcmFjZSIsInNldEhlYWRlciIsImRlc3Ryb3llZCIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uY2UiLCJiaW5kIiwicmVhc29uIiwicmVjZWl2ZXJPbkZpbmlzaCIsImlzQmluYXJ5IiwiY2h1bmsiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZWFkIiwid3JpdGUiLCJjbGVhclRpbWVvdXQiLCJmaW5pc2hlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(ssr)/./node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(ssr)/./node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(ssr)/./node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWDtBQUNKO0FBQ007QUFDYTtBQUV1QjtBQUMvRSxpRUFBZUcsOENBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanM/YzVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlV2ViU29ja2V0U3RyZWFtIGZyb20gJy4vbGliL3N0cmVhbS5qcyc7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSAnLi9saWIvcmVjZWl2ZXIuanMnO1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL2xpYi9zZW5kZXIuanMnO1xuaW1wb3J0IFdlYlNvY2tldCBmcm9tICcuL2xpYi93ZWJzb2NrZXQuanMnO1xuaW1wb3J0IFdlYlNvY2tldFNlcnZlciBmcm9tICcuL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlV2ViU29ja2V0U3RyZWFtLCBSZWNlaXZlciwgU2VuZGVyLCBXZWJTb2NrZXQsIFdlYlNvY2tldFNlcnZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiV2ViU29ja2V0IiwiV2ViU29ja2V0U2VydmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/wrapper.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(rsc)/./node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(rsc)/./node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(rsc)/./node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWDtBQUNKO0FBQ007QUFDYTtBQUV1QjtBQUMvRSxpRUFBZUcsOENBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG93c3RhdGUtY2F0YWx5c3QvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanM/YzVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlV2ViU29ja2V0U3RyZWFtIGZyb20gJy4vbGliL3N0cmVhbS5qcyc7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSAnLi9saWIvcmVjZWl2ZXIuanMnO1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL2xpYi9zZW5kZXIuanMnO1xuaW1wb3J0IFdlYlNvY2tldCBmcm9tICcuL2xpYi93ZWJzb2NrZXQuanMnO1xuaW1wb3J0IFdlYlNvY2tldFNlcnZlciBmcm9tICcuL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlV2ViU29ja2V0U3RyZWFtLCBSZWNlaXZlciwgU2VuZGVyLCBXZWJTb2NrZXQsIFdlYlNvY2tldFNlcnZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiV2ViU29ja2V0IiwiV2ViU29ja2V0U2VydmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/wrapper.mjs\n");

/***/ })

};
;